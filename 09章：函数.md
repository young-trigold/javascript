**目录：**

- [9. 函数](#9-函数)
  - [9.1. 创建函数](#91-创建函数)
    - [9.1.1. 函数声明](#911-函数声明)
    - [9.1.2. 函数表达式](#912-函数表达式)
    - [9.1.3. 箭头函数](#913-箭头函数)
    - [9.1.4. Function() 构造函数](#914-function-构造函数)
  - [9.2. 理解函数](#92-理解函数)
    - [9.2.1. 函数的本质](#921-函数的本质)
    - [9.2.3. 立即调用函数表达式](#923-立即调用函数表达式)
  - [9.3. 参数](#93-参数)
    - [9.3.1. 没有重载](#931-没有重载)
    - [9.3.2. 默认参数值](#932-默认参数值)
    - [9.3.3. 参数扩展和收集](#933-参数扩展和收集)
  - [9.4. 函数内部](#94-函数内部)
    - [9.4.1. arguments](#941-arguments)
    - [9.4.2. this](#942-this)
    - [9.4.3. new.target](#943-newtarget)
  - [9.5. 函数属性](#95-函数属性)
    - [9.5.1. name](#951-name)
    - [9.5.2. length](#952-length)
    - [9.5.3. caller](#953-caller)
    - [9.5.4. 其他属性](#954-其他属性)
  - [9.6. 函数方法](#96-函数方法)
    - [9.6.1. call()](#961-call)
    - [9.6.2. apply()](#962-apply)
    - [9.6.3. bind()](#963-bind)
    - [9.6.4. 其他函数方法](#964-其他函数方法)
  - [9.7. 闭包](#97-闭包)
    - [9.7.1. this 对象](#971-this-对象)
    - [9.7.2. 内存泄漏](#972-内存泄漏)
  - [9.9. 私有变量](#99-私有变量)
    - [9.9.1. 静态私有变量](#991-静态私有变量)
    - [9.9.2. 模块模式](#992-模块模式)
    - [9.9.3. 模块增强模式](#993-模块增强模式)
  - [9.8. 尾调用优化](#98-尾调用优化)
    - [9.8.1. 尾调用优化的条件](#981-尾调用优化的条件)
    - [9.8.2. 尾调用优化的代码](#982-尾调用优化的代码)

# 9. 函数

本章内容

- 创建函数的方式
- 理解函数
- 使用参数
- 函数内部
- 函数属性与方法
- 闭包
- 私有变量
- 尾调用优化

函数是 ECMAScript 中最有意思的部分之一，这主要是因为函数实际上是对象。每个函数都是 Function 类型的实例，而 Function 也有属性和方法，跟其他引用类型一样。因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定。

## 9.1. 创建函数

在 JavaScript 中，可以通过函数声明，函数表达式，箭头函数，以及 Function() 构造函数创建一个函数实例。这 4 种方式各有特点，理解这 4 种方法的区别是非常重要的。

### 9.1.1. 函数声明

函数通常以函数声明的方式定义，比如：

```javascript
function sum(num1, num2) {
  return num1 + num2;
}
```

注意函数定义最后没有加分号。

**函数声明提升**

JavaScript 引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义。来看下面的例子：

```javascript
// 没问题
console.log(sum(10, 10));
function sum(num1, num2) {
  return num1 + num2;
}
```

以上代码可以正常运行，因为函数声明会在任何代码执行之前先被读取并添加到执行上下文。这个过程叫作 **函数声明提升(function declaration hoisting)**。在执行代码时，JavaScript 引擎会先执行一遍扫描，把发现的函数声明提升到源代码树的顶部。因此即使函数定义出现在调用它们的代码之后，引擎也会把函数声明提升到顶部。

需要注意的是，函数定义声明的提升优先级高于 var 变量的提升优先级，例如：

```javascript
var foo = 'foo';
function foo() {}
console.log(typeof foo);
// string
```

以上代码实际上等价于：

```javascript
function foo() {}
var foo;
foo = 'foo';
console.log(typeof foo);
// string
```

### 9.1.2. 函数表达式

另一种定义函数的语法是函数表达式。函数表达式与函数声明几乎是等价的：

```javascript
let sum = function (num1, num2) {
  return num1 + num2;
};
```

这里，代码定义了一个变量 sum 并将其初始化为一个函数。注意 function 关键字后面没有名称，因为不需要。这个函数可以通过变量 sum 来引用。

注意这里的函数末尾是有分号的，与任何变量初始化语句一样。

函数表达式看起来就像一个普通的变量定义和赋值，即创建一个函数再把它赋值给一个变量 functionName。这样创建的函数叫作 **匿名函数(anonymous funtion)**，因为 function 关键字后面没有标识符。未赋值给其他变量的匿名函数的 name 属性是空字符串。

函数表达式跟 JavaScript 中的其他表达式一样，需要先赋值再使用。下面的例子会导致错误：

```javascript
sayHi(); // Error! function doesn't exist yet
let sayHi = function () {
  console.log('Hi!');
};
```

理解函数声明与函数表达式之间的区别，关键是理解提升。比如，以下代码的执行结果可能会出乎意料：

```javascript
// 千万别这样做！
if (condition) {
  function sayHi() {
    console.log('Hi!');
  }
} else {
  function sayHi() {
    console.log('Yo!');
  }
}
```

这段代码看起来很正常，就是如果 condition 为 true，则使用第一个 sayHi()定义；否则，就使用第二个。事实上，这种写法在 ECAMScript 中不是有效的语法。JavaScript 引擎会尝试将其纠正为适当的声明。问题在于浏览器纠正这个问题的方式并不一致。多数浏览器会忽略 condition 直接返回第二个声明。Firefox 会在 condition 为 true 时返回第一个声明。这种写法很危险，不要使用。不过，如果把上面的函数声明换成函数表达式就没问题了：

```javascript
// 没问题
let sayHi;
if (condition) {
  sayHi = function () {
    console.log('Hi!');
  };
} else {
  sayHi = function () {
    console.log('Yo!');
  };
}
```

这个例子可以如预期一样，根据 condition 的值为变量 sayHi 赋予相应的函数。

创建函数并赋值给变量的能力也可以用于在一个函数中把另一个函数当作值返回：

```javascript
function createComparisonFunction(propertyName) {
  return function (object1, object2) {
    let value1 = object1[propertyName];
    let value2 = object2[propertyName];
    if (value1 < value2) {
      return -1;
    } else if (value1 > value2) {
      return 1;
    } else {
      return 0;
    }
  };
}
```

这里的 createComparisonFunction()函数返回一个匿名函数，这个匿名函数要么被赋值给一个变量，要么可以直接调用。但在 createComparisonFunction()内部，那个函数是匿名的。任何时候，只要函数被当作值来使用，它就是一个函数表达式。

**命名函数表达式**

**递归函数** 通常的形式是一个函数通过名称调用自己，如下面的例子所示：

```javascript
function factorial(num) {
  if (num <= 1) {
    return 1;
  } else {
    return num * factorial(num - 1);
  }
}
```

这是经典的递归阶乘函数。虽然这样写是可以的，但如果把这个函数赋值给其他变量，就会出问题：

```javascript
const anotherFactorial = factorial;
factorial = null;

// 报错
console.log(anotherFactorial(4));
```

这里把 factorial()函数保存在了另一个变量 anotherFactorial 中，然后将 factorial 设置为 null，于是只保留了一个对原始函数的引用。而在调用 anotherFactorial()时，要递归调用 factorial()，但因为它已经不是函数了，所以会出错。在写递归函数时使用 arguments.callee 可以避免这个问题。

arguments.callee 就是一个指向正在执行的函数的指针，因此可以在函数内部递归调用，如下所示：

```javascript
function factorial(num) {
  if (num <= 1) {
    return 1;
  } else {
    return num * arguments.callee(num - 1);
  }
}
```

像这里加粗的这一行一样，把函数名称替换成 arguments.callee，可以确保无论通过什么变量调用这个函数都不会出问题。因此在编写递归函数时，arguments.callee 是引用当前函数的首选。

不过，在严格模式下运行的代码是不能访问 arguments.callee 的，因为访问会出错。此时，可以使用 **命名函数表达式(named function expression)** 达到目的。比如：

```javascript
const factorial = function f(num) {
  if (num <= 1) {
    return 1;
  } else {
    return num * f(num - 1);
  }
};
```

这里创建了一个命名函数表达式 f()，然后将它赋值给了变量 factorial。即使把函数赋值给另一个变量，函数表达式的名称 f 也不变，因此递归调用不会有问题。这个模式在严格模式和非严格模式下都可以使用。

### 9.1.3. 箭头函数

还有一种定义函数的方式与函数表达式很像，叫作 **箭头函数(arrow function)** ，如下所示：

```javascript
const sum = (num1, num2) => {
  return num1 + num2;
};
```

很大程度上，箭头函数实例化的函数对象与正式的函数表达式创建的函数对象行为是相同的。任何可以使用函数表达式的地方，都可以使用箭头函数：

```javascript
const arrowSum = (a, b) => {
  return a + b;
};

const functionExpressionSum = function (a, b) {
  return a + b;
};

console.log(arrowSum(5, 8));
// -> 13

console.log(functionExpressionSum(5, 8));
// -> 13
```

箭头函数表达式的语法比函数表达式更简洁，更适用于那些本来需要匿名函数的地方：

```javascript
const ints = [1, 2, 3];

console.log(
  ints.map(function (i) {
    return i + 1;
  }),
);
// -> [2, 3, 4]

console.log(
  ints.map((i) => {
    return i + 1;
  }),
);
// -> [2, 3, 4]
```

如果只有一个参数，那也可以不用括号。只有没有参数，或者多个参数的情况下，才需要使用括号：

```javascript
// 以下两种写法都有效
const double = (x) => { return 2 * x; };
const triple = x => { return 3 * x; };

// 没有参数需要括号
const getRandom = () => { return Math.random(); };

// 多个参数需要括号
const sum = (a, b) => { return a + b; };

// 无效的写法：
const multiply = a, b => { return a * b; };
```

箭头函数也可以不用大括号，但这样会改变函数的行为。使用大括号就说明包含“函数体”，可以在一个函数中包含多条语句，跟常规的函数一样。如果不使用大括号，那么箭头后面就只能有一行代码，比如一个赋值操作，或者一个表达式。而且，省略大括号会隐式返回这行代码的值：

```javascript
// 以下两种写法都有效，而且返回相应的值
const double = (x) => { return 2 * x; };
const triple = (x) => 3 * x;

// 可以赋值
let value = {};
const setName = (x) => x.name = 'Matt';
setName(value);
console.log(value.name);
// -> 'Matt'

// 无效的写法：
const multiply = (a, b) => return a * b;
```

如果要返回一个对象字面量，就要加上括号：

```javascript
(params) => ({foo: bar});
```

箭头函数虽然语法简洁，但也有很多场合不适用。箭头函数没有自己的 this，arguments，super，new.target 以及 prototype。当然它也不能用作构造函数。

来看下面这个例子：

```javascript
const arrowFunc = ()=>{
 // ReferenceError: arguments is not defined
 console.log(arguments);

 // SyntaxError: new.target expression is not allowed here
 console.log(new.target);
};

arrowFunc();

console.log(arrowFunc.prototype);
// -> undefined
```

在箭头函数内部没有 arguments，不能使用 new.target，当然也不能用作构造函数。箭头函数的 prototype 返回 undefined。

### 9.1.4. Function() 构造函数

最后一种定义函数的方式是使用 Function 构造函数。这个构造函数接收任意多个字符串参数，最后一个参数始终会被当成函数体，而之前的参数都是新函数的参数。来看下面的例子：

```javascript
// 不推荐
const sum = new Function('num1', 'num2', 'return num1 + num2');
```

我们不推荐使用这种语法来定义函数，因为这段代码会被解释两次：第一次是将它当作常规 ECMAScript 代码，第二次是解释传给构造函数的字符串。这显然会影响性能。不过，把函数想象为对象，把函数名想象为指针是很重要的。而上面这种语法很好地诠释了这些概念。

## 9.2. 理解函数

### 9.2.1. 函数的本质

函数本质上是 Function 类型的对象。

1. **可调用性**

Function 类型对象和非 Function 类型对象的显著区别就是 **可调用性(Callable)**，说一个对象是可调用的，意味着你可以在对象后加上小括号，并可以在括号里写入调用参数。

来看这个例子。

```javascript
const func = function () {
  console.log('be called');
};

func();

const notFunc = {};

// TypeError: notFunc is not a function
notFunc();
```

在这个例子中，func 对象是一个 Function 类型的对象，这很显然，我们用匿名函数表达式赋值给了 func。而 notFunc 是一个非 Function 类型的对象，因为我们用对象字面量赋值给了 notFunc。因此，当我们在 func 对象后加上括号调用时，没有报错。而 notFunc 则提示 notFunc 不是一个函数。

2. **函数也有属性或方法**

函数是 Function 类型的对象，这意味着一个函数也和对象一样有属性或方法。

Function 类型的对象，除了箭头函数以外，都有一个属性 prototype，用于实现原型链继承。Function 类型的对象也有 name，length 属性，分别表示函数的名称和参数个数。这些属性在后面章节会详细讨论。

Function 类型的对象也有方法，如：call()，apply()，bind() 方法，这些方法用于指定函数被调用时的内部 this 值。这些方法在后面章节会详细讨论。

3. **函数也是值**

函数是 Function 类型的对象，这也表示一个函数就是一个引用值，这是显然的。因此，函数也可以被赋值给一个变量，当然也可以当作参数传进函数。

来看第 1 个例子：

```javascript
const func1 = function () {
  console.log('be called');
};

const func2 = func1;
func1.foo = 'foo';
console.log(func2.foo);
// -> 'foo'
```

在这个例子中，我们先定义了一个函数表达式（函数），把它赋值给了 func1，之后再把 func1 这个引用值赋值给 func2，显然，这是一次浅拷贝，因此，当我们给 func1 添加了 foo 属性时，func2 也被添加了 foo 属性。

来看第 2 个例子：

```javascript
function callSomeFunction(someFunction, someArgument) {
  return someFunction(someArgument);
}
```

这个函数接收两个参数。第一个参数应该是一个函数，第二个参数应该是要传给这个函数的值。任何函数都可以像下面这样作为参数传递：

```javascript
function add10(num) {
  return num + 10;
}
let result1 = callSomeFunction(add10, 10);
console.log(result1); // 20
function getGreeting(name) {
  return 'Hello, ' + name;
}
let result2 = callSomeFunction(getGreeting, 'Nicholas');
console.log(result2); // 'Hello, Nicholas'
```

callSomeFunction()函数是通用的，第一个参数传入的是什么函数都可以，而且它始终返回调用作为第一个参数传入的函数的结果。要注意的是，如果是访问函数而不是调用函数，那就必须不带括号，所以传给 callSomeFunction()的必须是 add10 和 getGreeting，而不能是它们的执行结果。

从一个函数中返回另一个函数也是可以的，而且非常有用。例如，假设有一个包含对象的数组，而我们想按照任意对象属性对数组进行排序。为此，可以定义一个 sort()方法需要的比较函数，它接收两个参数，即要比较的值。但这个比较函数还需要想办法确定根据哪个属性来排序。这个问题可以通过定义一个根据属性名来创建比较函数的函数来解决。比如：

```javascript
function createComparisonFunction(propertyName) {
  return function (object1, object2) {
    let value1 = object1[propertyName];
    let value2 = object2[propertyName];
    if (value1 < value2) {
      return -1;
    } else if (value1 > value2) {
      return 1;
    } else {
      return 0;
    }
  };
}
```

这个函数的语法乍一看比较复杂，但实际上就是在一个函数中返回另一个函数，注意那个 return 操作符。内部函数可以访问 propertyName 参数，并通过中括号语法取得要比较的对象的相应属性值。取得属性值以后，再按照 sort()方法的需要返回比较值就行了。这个函数可以像下面这样使用：

```javascript
let data = [
  {name: 'Zachary', age: 28},
  {name: 'Nicholas', age: 29},
];
data.sort(createComparisonFunction('name'));
console.log(data[0].name); // Nicholas
data.sort(createComparisonFunction('age'));
console.log(data[0].name); // Zachary
```

在上面的代码中，数组 data 中包含两个结构相同的对象。每个对象都有一个 name 属性和一个 age 属性。默认情况下，sort()方法要对这两个对象执行 toString()，然后再决定它们的顺序，但这样得不到有意义的结果。而通过调用 createComparisonFunction('name')来创建一个比较函数，就可以根据每个对象 name 属性的值来排序，结果 name 属性值为'Nicholas'、age 属性值为 29 的对象会排在前面。而调用 createComparisonFunction('age')则会创建一个根据每个对象 age 属性的值来排序的比较函数，结果 name 属性值为'Zachary'、age 属性值为 28 的对象会排在前面。

### 9.2.3. 立即调用函数表达式

通常当我们定义好一个函数表达式后，我们会将它赋值给一个变量：

```javascript
const func = function () {
  console.log('be called');
};
```

这样做的好处就是我们可以使用这个变量名在之后的代码中多次调用：

```javascript
// ...
func();
// ...
func();
```

但是，我们实际上也可以直接在这个函数表达式之后加上括号来调用，为了避免语法识别错误，我们还要将这个函数表达式用小括号括起来表示它是一个整体：

```javascript
(function () {
  console.log('be called');
})();
// -> 'be called'
```

这种写法合理的原因就在于函数表达式实际上就是一个 Function 类型的对象，因此我们可以在其后加上括号来调用。和通常我们将函数表达式赋值给一个变量的写法不同的是：这个函数表达式无法通过变量名调用，而且这个函数表达式在定义之后被 **立即调用**。以这种写法调用的函数表达式又被称作 **立即调用函数表达式(IIFE，Immediately Invoked Function Expression)**。

使用 IIFE 可以模拟块级作用域，即在一个函数表达式内部声明变量，然后立即调用这个函数。这样位于函数体作用域的变量就像是在块级作用域中一样。ECMAScript 5 尚未支持块级作用域，使用 IIFE 模拟块级作用域是相当普遍的。比如下面的例子：

```javascript
// IIFE
(function () {
  for (var i = 0; i < count; i++) {
    console.log(i);
  }
})();
console.log(i); // 抛出错误
```

前面的代码在执行到 IIFE 外部的 console.log()时会出错，因为它访问的变量是在 IIFE 内部定义的，在外部访问不到。在 ECMAScript 5.1 及以前，为了防止变量定义外泄，IIFE 是个非常有效的方式。这样也不会导致闭包相关的内存问题，因为不存在对这个匿名函数的引用。为此，只要函数执行完毕，其作用域链就可以被销毁。

在 ECMAScript 6 以后，IIFE 就没有那么必要了，因为块级作用域中的变量无须 IIFE 就可以实现同样的隔离。下面展示了两种不同的块级作用域形式：

```javascript
// 内嵌块级作用域
{
  let i;
  for (i = 0; i < count; i++) {
    console.log(i);
  }
}
console.log(i); // 抛出错误
// 循环的块级作用域
for (let i = 0; i < count; i++) {
  console.log(i);
}
console.log(i); // 抛出错误
```

说明 IIFE 用途的一个实际的例子，就是可以用它锁定参数值。比如：

```javascript
let divs = document.querySelectorAll('div');
// 达不到目的！
for (var i = 0; i < divs.length; ++i) {
  divs[i].addEventListener('click', function () {
    console.log(i);
  });
}
```

这里使用 var 关键字声明了循环迭代变量 i，但这个变量并不会被限制在 for 循环的块级作用域内。因此，渲染到页面上之后，点击每个`<div>`都会弹出元素总数。这是因为在执行单击处理程序时，迭代变量的值是循环结束时的最终值，即元素的个数。而且，这个变量 i 存在于循环体外部，随时可以访问。

以前，为了实现点击第几个`<div>`就显示相应的索引值，需要借助 IIFE 来执行一个函数表达式，传入每次循环的当前索引，从而“锁定”点击时应该显示的索引值：

```javascript
let divs = document.querySelectorAll('div');
for (var i = 0; i < divs.length; ++i) {
  divs[i].addEventListener(
    'click',
    (function (frozenCounter) {
      return function () {
        console.log(frozenCounter);
      };
    })(i),
  );
}
```

而使用 ECMAScript 块级作用域变量，就不用这么大动干戈了：

```javascript
let divs = document.querySelectorAll('div');
for (let i = 0; i < divs.length; ++i) {
  divs[i].addEventListener('click', function () {
    console.log(i);
  });
}
```

这样就可以让每次点击都显示正确的索引了。这里，事件处理程序执行时就会引用 for 循环块级作用域中的索引值。这是因为在 ECMAScript 6 中，如果对 for 循环使用块级作用域变量关键字，在这里就是 let，那么循环就会为每个循环创建独立的变量，从而让每个单击处理程序都能引用特定的索引。

但要注意，如果把变量声明拿到 for 循环外部，那就不行了。下面这种写法会碰到跟在循环中使用 var i = 0 同样的问题：

```javascript
let divs = document.querySelectorAll('div');
// 达不到目的！
let i;
for (i = 0; i < divs.length; ++i) {
  divs[i].addEventListener('click', function () {
    console.log(i);
  });
}
```

## 9.3. 参数

ECMAScript 函数的参数跟大多数其他语言不同。ECMAScript 函数既不关心传入的参数个数，也不关心这些参数的数据类型。定义函数时要接收两个参数，并不意味着调用时就传两个参数。你可以传一个、三个，甚至一个也不传，解释器都不会报错。

之所以会这样，主要是因为 ECMAScript 函数的参数在内部表现为一个数组。函数被调用时总会接收一个数组，但函数并不关心这个数组中包含什么。如果数组中什么也没有，那没问题；如果数组的元素超出了要求，那也没问题。事实上，在使用 function 关键字定义（非箭头）函数时，可以在函数内部访问 arguments 对象，从中取得传进来的每个参数值。

arguments 对象既是一个类数组对像，又是一个可迭代对象。要确定传进来多少个参数，可以访问 arguments.length 属性。

在下面的例子中，sayHi()函数的第一个参数叫 name：

```javascript
function sayHi(name, message) {
  console.log('Hello ' + name + ', ' + message);
}
```

可以通过 arguments[0] 取得相同的参数值。因此，把函数重写成不声明参数也可以：

```javascript
function sayHi() {
  console.log('Hello ' + arguments[0] + ', ' + arguments[1]);
}
```

在重写后的代码中，没有命名参数。name 和 message 参数都不见了，但函数照样可以调用。这就表明，ECMAScript 函数的参数只是为了方便才写出来的，并不是必须写出来的。与其他语言不同，在 ECMAScript 中的命名参数不会创建让之后的调用必须匹配的函数签名。这是因为根本不存在验证命名参数的机制。

也可以通过 arguments 对象的 length 属性检查传入的参数个数。下面的例子展示了在每调用一个函数时，都会打印出传入的参数个数：

```javascript
function howManyArgs() {
  console.log(arguments.length);
}
howManyArgs('string', 45); // 2
howManyArgs(); // 0
howManyArgs(12); // 1
```

这个例子分别打印出 2、0 和 1（按顺序）。既然如此，那么开发者可以想传多少参数就传多少参数。比如：

```javascript
function doAdd() {
  return Array.from(arguments).reduce((pre, cur) => pre + cur, 0);
}

console.log(doAdd()); // 0
console.log(doAdd(1, 2)); // 3
console.log(doAdd(1, 2, 3, 4, 5)); // 15
```

这个函数 doAdd() 在没有参数时，返回初始值 0。在有参数时使用 Array.from() 将 arguments 对象转为数组，并用归并方法 reduce() 返回参数的和。

还有一个必须理解的重要方面，那就是 arguments 对象可以跟命名参数一起使用，比如：

```javascript
function doAdd(num1, num2) {
  if (arguments.length === 1) {
    console.log(num1 + 10);
  } else if (arguments.length === 2) {
    console.log(arguments[0] + num2);
  }
}
```

arguments 对象的另一个有意思的地方就是，它的值始终会与对应的命名参数同步。来看下面的例子：

```javascript
function doAdd(num1, num2) {
  arguments[1] = 10;
  console.log(arguments[0] + num2);
}
```

这个 doAdd()函数把第二个参数的值重写为 10。因为 arguments 对象的值会自动同步到对应的命名参数，所以修改 arguments[1]也会修改 num2 的值，因此两者的值都是 10。但这并不意味着它们都访问同一个内存地址，它们在内存中还是分开的，只不过会保持同步而已。另外还要记住一点：如果只传了一个参数，然后把 arguments[1]设置为某个值，那么这个值并不会反映到第二个命名参数。这是因为 arguments 对象的长度是根据传入的参数个数，而非定义函数时给出的命名参数个数确定的。

对于命名参数而言，如果调用函数时没有传这个参数，那么它的值就是 undefined。这就类似于定义了变量而没有初始化。比如，如果只给 doAdd()传了一个参数，那么 num2 的值就是 undefined。

严格模式下，arguments 会有一些变化。首先，像前面那样给 arguments[1]赋值不会再影响 num2 的值。就算把 arguments[1]设置为 10，num2 的值仍然还是传入的值。其次，在函数中尝试重写 arguments 对象会导致语法错误。（代码也不会执行。）

**箭头函数中的参数**

如果函数是使用箭头语法定义的，那么传给函数的参数将不能使用 arguments 关键字访问，而只能通过定义的命名参数访问。

```javascript
function foo() {
  console.log(arguments[0]);
}
foo(5); // 5
let bar = () => {
  console.log(arguments[0]);
};
bar(5); // ReferenceError: arguments is not defined
```

虽然箭头函数中没有 arguments 对象，但可以在包装函数中把它提供给箭头函数：

```javascript
function foo() {
  let bar = () => {
    console.log(arguments[0]); // 5
  };
  bar();
}
foo(5);
```

注意 ECMAScript 中的所有参数都按值传递的。不可能按引用传递参数。如果把对象作为参数传递，那么传递的值就是这个对象的引用。

### 9.3.1. 没有重载

ECMAScript 函数不能像传统编程那样重载。在其他语言比如 Java 中，一个函数可以有两个定义，只要签名（接收参数的类型和数量）不同就行。如前所述，ECMAScript 函数没有签名，因为参数是由包含零个或多个值的数组表示的。没有函数签名，自然也就没有重载。

如果在 ECMAScript 中声明了两个同名的函数定义，则后定义的会覆盖先定义的。来看下面的例子：

```javascript
function addSomeNumber(num) {
  return num + 100;
}
function addSomeNumber(num) {
  return num + 200;
}
let result = addSomeNumber(100); // 300
```

这里，函数 addSomeNumber()被定义了两次。第一个版本给参数加 100，第二个版本加 200。最后一行调用这个函数时，返回了 300，因为第二个定义覆盖了第一个定义。

前面也提到过，可以通过检查参数的类型和数量，然后分别执行不同的逻辑来模拟函数重载。

把函数名当成指针也有助于理解为什么 ECMAScript 没有函数重载。在前面的例子中，定义两个同名的函数显然会导致后定义的重写先定义的。而那个例子几乎跟下面这个是一样的：

```javascript
let addSomeNumber = function (num) {
  return num + 100;
};
addSomeNumber = function (num) {
  return num + 200;
};
let result = addSomeNumber(100); // 300
```

看这段代码应该更容易理解发生了什么。在创建第二个函数时，变量 addSomeNumber 被重写成保存第二个函数对象了。

### 9.3.2. 默认参数值

在 ECMAScript5.1 及以前，实现默认参数的一种常用方式就是检测某个参数是否等于 undefined，如果是则意味着没有传这个参数，那就给它赋一个值：

```javascript
function makeKing(name) {
  name = typeof name !== 'undefined' ? name : 'Henry';
  return `King ${name} VIII`;
}
console.log(makeKing()); // 'King Henry VIII'
console.log(makeKing('Louis')); // 'King Louis VIII'
```

ECMAScript 6 之后就不用这么麻烦了，因为它支持显式定义默认参数了。下面就是与前面代码等价的 ES6 写法，只要在函数定义中的参数后面用=就可以为参数赋一个默认值：

```javascript
function makeKing(name = 'Henry') {
  return `King ${name} VIII`;
}
console.log(makeKing('Louis')); // 'King Louis VIII'
console.log(makeKing()); // 'King Henry VIII'
```

给参数传 undefined 相当于没有传值，不过这样可以利用多个独立的默认值：

```javascript
function makeKing(name = 'Henry', numerals = 'VIII') {
  return `King ${name} ${numerals}`;
}
console.log(makeKing()); // 'King Henry VIII'
console.log(makeKing('Louis')); // 'King Louis VIII'
console.log(makeKing(undefined, 'VI')); // 'King Henry VI'
```

在使用默认参数时，arguments 对象的值不反映参数的默认值，只反映传给函数的参数。当然，跟 ES5 严格模式一样，修改命名参数也不会影响 arguments 对象，它始终以调用函数时传入的值为准：

```javascript
function makeKing(name = 'Henry') {
  name = 'Louis';
  return `King ${arguments[0]}`;
}
console.log(makeKing()); // 'King undefined'
console.log(makeKing('Louis')); // 'King Louis'
```

默认参数值并不限于原始值或对象类型，也可以使用调用函数返回的值：

```javascript
let romanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI'];
let ordinality = 0;
function getNumerals() {
  // 每次调用后递增
  return romanNumerals[ordinality++];
}
function makeKing(name = 'Henry', numerals = getNumerals()) {
  return `King ${name} ${numerals}`;
}
console.log(makeKing()); // 'King Henry I'
console.log(makeKing('Louis', 'XVI')); // 'King Louis XVI'
console.log(makeKing()); // 'King Henry II'
console.log(makeKing()); // 'King Henry III'
```

函数的默认参数只有在函数被调用时才会求值，不会在函数定义时求值。而且，计算默认值的函数只有在调用函数但未传相应参数时才会被调用。

箭头函数同样也可以这样使用默认参数，只不过在只有一个参数时，就必须使用括号而不能省略了：

```javascript
let makeKing = (name = 'Henry') => `King ${name}`;
console.log(makeKing()); // King Henry
```

**默认参数作用域与暂时性死区**

因为在求值默认参数时可以定义对象，也可以动态调用函数，所以函数参数肯定是在某个作用域中求值的。

给多个参数定义默认值实际上跟使用 let 关键字顺序声明变量一样。来看下面的例子：

```javascript
function makeKing(name = 'Henry', numerals = 'VIII') {
  return `King ${name} ${numerals}`;
}
console.log(makeKing()); // King Henry VIII
```

这里的默认参数会按照定义它们的顺序依次被初始化。可以依照如下示例想象一下这个过程：

```javascript
function makeKing() {
  let name = 'Henry';
  let numerals = 'VIII';
  return `King ${name} ${numerals}`;
}
```

因为参数是按顺序初始化的，所以后定义默认值的参数可以引用先定义的参数。看下面这个例子：

```javascript
function makeKing(name = 'Henry', numerals = name) {
  return `King ${name} ${numerals}`;
}
console.log(makeKing()); // King Henry Henry
```

参数初始化顺序遵循“暂时性死区”规则，即前面定义的参数不能引用后面定义的。像这样就会抛出错误：

```javascript
// 调用时不传第一个参数会报错
function makeKing(name = numerals, numerals = 'VIII') {
  return `King ${name} ${numerals}`;
}
```

参数也存在于自己的作用域中，它们不能引用函数体的作用域：

```javascript
// 调用时不传第二个参数会报错
function makeKing(name = 'Henry', numerals = defaultNumeral) {
  let defaultNumeral = 'VIII';
  return `King ${name} ${numerals}`;
}
```

### 9.3.3. 参数扩展和收集

ECMAScript 6 新增了扩展操作符，使用它可以非常简洁地操作和组合集合数据。扩展操作符最有用的场景就是函数定义中的参数列表，在这里它可以充分利用这门语言的弱类型及参数长度可变的特点。扩展操作符既可以用于调用函数时传参，也可以用于定义函数参数。

1. 扩展参数

在给函数传参时，有时候可能不需要传一个数组，而是要分别传入数组的元素。

假设有如下函数定义，它会将所有传入的参数累加起来：

```javascript
let values = [1, 2, 3, 4];
function getSum() {
  return Array.from(arguments).reduce((pre, cur) => pre + cur, 0);
}
```

这个函数希望将传入的数组拆分，然后累加。如果不使用扩展操作符，想把定义在这个函数这面的数组拆分，那么就得求助于 apply()方法：

```javascript
console.log(getSum.apply(null, values)); // 10
```

但在 ECMAScript 6 中，可以通过扩展操作符极为简洁地实现这种操作。对可迭代对象应用扩展操作符，并将其作为一个参数传入，可以将可迭代对象拆分，并将迭代返回的每个值单独传入。

比如，使用扩展操作符可以将前面例子中的数组像这样直接传给函数：

```javascript
console.log(getSum(...values)); // 10
```

因为数组的长度已知，所以在使用扩展操作符传参的时候，并不妨碍在其前面或后面再传其他的值，包括使用扩展操作符传其他参数：

```javascript
console.log(getSum(-1, ...values)); // 9
console.log(getSum(...values, 5)); // 15
console.log(getSum(-1, ...values, 5)); // 14
console.log(getSum(...values, ...[5, 6, 7])); // 28
```

对函数中的 arguments 对象而言，它并不知道扩展操作符的存在，而是按照调用函数时传入的参数接收每一个值：

```javascript
let values = [1, 2, 3, 4];
function countArguments() {
  console.log(arguments.length);
}
countArguments(-1, ...values); // 5
countArguments(...values, 5); // 5
countArguments(-1, ...values, 5); // 6
countArguments(...values, ...[5, 6, 7]); // 7
```

arguments 对象只是消费扩展操作符的一种方式。在普通函数和箭头函数中，也可以将扩展操作符用于命名参数，当然同时也可以使用默认参数：

```javascript
function getProduct(a, b, c = 1) {
  return a * b * c;
}
let getSum = (a, b, c = 0) => {
  return a + b + c;
};
console.log(getProduct(...[1, 2])); // 2
console.log(getProduct(...[1, 2, 3])); // 6
console.log(getProduct(...[1, 2, 3, 4])); // 6
console.log(getSum(...[0, 1])); // 1
console.log(getSum(...[0, 1, 2])); // 3
console.log(getSum(...[0, 1, 2, 3])); // 3
```

2. 收集参数

在构思函数定义时，可以使用扩展操作符把不同长度的独立参数组合为一个数组。这有点类似 arguments 对象的构造机制，只不过收集参数的结果会得到一个 Array 实例。

```javascript
function getSum(...values) {
  // 顺序累加values 中的所有值
  // 初始值的总和为0
  return values.reduce((x, y) => x + y, 0);
}
console.log(getSum(1, 2, 3)); // 6
```

收集参数的前面如果还有命名参数，则只会收集其余的参数；如果没有则会得到空数组。因为收集参数的结果可变，所以只能把它作为最后一个参数：

```javascript
// 不可以
function getProduct(...values, lastValue) {}
// 可以
function ignoreFirst(firstValue, ...values) {
  console.log(values);
}
ignoreFirst(); // []
ignoreFirst(1); // []
ignoreFirst(1,2); // [2]
ignoreFirst(1,2,3); // [2, 3]
```

箭头函数虽然不支持 arguments 对象，但支持收集参数的定义方式，因此也可以实现与使用 arguments 一样的逻辑：

```javascript
let getSum = (...values) => {
  return values.reduce((x, y) => x + y, 0);
};
console.log(getSum(1, 2, 3)); // 6
```

另外，使用收集参数并不影响 arguments 对象，它仍然反映调用时传给函数的参数：

```javascript
function getSum(...values) {
  console.log(arguments.length); // 3
  console.log(arguments); // [1, 2, 3]
  console.log(values); // [1, 2, 3]
}
console.log(getSum(1, 2, 3));
```

## 9.4. 函数内部

在 ECMAScript 5 中，函数内部存在两个特殊的对象：arguments 和 this。ECMAScript 6 又新增了 new.target 属性。

### 9.4.1. arguments

arguments 对象前面讨论过多次了，它是既是一个类数组对象，又是一个可迭代对象，包含调用函数时传入的所有参数。这个对象只有以 function 关键字定义函数（相对于使用箭头语法创建函数）时才会有。虽然主要用于包含函数参数，但 arguments 对象其实还有一个 callee 属性，是一个指向 arguments 对象所在函数的指针。来看下面这个经典的阶乘函数：

```javascript
function factorial(num) {
  if (num <= 1) {
    return 1;
  } else {
    return num * factorial(num - 1);
  }
}
```

阶乘函数一般定义成递归调用的，就像上面这个例子一样。只要给函数一个名称，而且这个名称不会变，这样定义就没有问题。但是，这个函数要正确执行就必须保证函数名是 factorial，从而导致了紧密耦合。使用 arguments.callee 就可以让函数逻辑与函数名解耦：

```javascript
function factorial(num) {
  if (num <= 1) {
    return 1;
  } else {
    return num * arguments.callee(num - 1);
  }
}
```

这个重写之后的 factorial()函数已经用 arguments.callee 代替了之前硬编码的 factorial。这意味着无论函数叫什么名称，都可以引用正确的函数。考虑下面的情况：

```javascript
let trueFactorial = factorial;
factorial = function () {
  return 0;
};
console.log(trueFactorial(5)); // 120
console.log(factorial(5)); // 0
```

这里，trueFactorial 变量被赋值为 factorial，实际上把同一个函数的指针又保存到了另一个位置。然后，factorial 函数又被重写为一个返回 0 的函数。如果像 factorial()最初的版本那样不使用 arguments.callee，那么像上面这样调用 trueFactorial()就会返回 0。不过，通过将函数与名称解耦，trueFactorial()就可以正确计算阶乘，而 factorial()则只能返回 0。

### 9.4.2. this

另一个特殊的对象是 this。this 的值取决于多种因素。

1. **全局上下文**

this 在全局上下文中，即在任何函数体的外部时，都指向全局对象，在浏览器宿主环境中就是 window。

来看下面的例子：

```javascript
let o1 = {
  this: this,
  o2: {
    this: [this],
  },
};

console.log(o1.this === window); // true
console.log(o1.o2.this[0] === window); // true
```

在这个例子中，对象 o1 的 this 属性引用 this 值，而这个 this 值在全局上下文中指向 window。同样的，o2 的 this 值引用一个数组对象，这个数组的第一个元素为 this，但无论如何 this 值都在全局上下文中，所以都指向 window。

2. **标准函数上下文**

this 出现在标准函数上下文中，此时的 this 取决于函数调用的方式。

- 在非严格模式下直接调用标准函数，则其内部的 this 指向全局对象。

来看下面几个例子：

```javascript
function getThis() {
  return this;
}
console.log(getThis() === window); // true
```

在这个例子中，getThis 是一个函数声明，它返回内部的 this 值。之后在全局上下文中直接调用了 getThis，它返回了全局对象。

非严格模式下直接调用标准函数，其内部的 this 值指向全局对象，而不论调用的上下文：

```javascript
function foo() {
  function getThis() {
    console.log(this === window); // true
  }
  getThis();
}
foo();
```

在这个例子中，getThis 在函数 foo 的上下文中直接调用，但不论是在全局上下文还是函数上下文中，非严格模式下直接调用标准函数，其内部的 this 都指向全局对象。

- 严格模式下直接调用标准函数，则其内部的 this 为 undefined。

来看下面几个例子：

```javascript
function getThisInStrict() {
  'use strict';
  return this;
}
console.log(getThisInStrict() === window); // false
console.log(getThisInStrict() === undefined); // true
```

在这个例子中，函数 getThisInStrict 的作用域内使用了严格模式。之后，在全局上下文中调用了 getThisInStrict，它内部的 this 为 undefined 而不是全局对象。

同样的，严格模式下直接调用标准函数，其内部的 this 为 undefined，而不论调用的上下文。

- 标准函数作为方法调用时，this 指向直接调用者，而非间接调用者。

来看下面几个例子：

```javascript
function getThis() {
  return this;
}

let o = {
  name: 'o',
};

o.getThis = getThis;
console.log(o.getThis().name); // o
```

在这个例子中，getThis 作为 o 的方法在全局上下文中调用。getThis 内部的 this 指向 o。

这个规则不受严格模式和调用方法时的上下文影响：

```javascript
'use strict';

function getThis() {
  return this;
}

function foo() {
  const o = {
    name: 'o',
  };
  o.getThis = getThis;
  console.log(o.getThis().name); // o
}
foo();
```

在这个例子中，全局使用了严格模式。之后在函数 foo 上下文中，getThis 作为 o 的方法被调用。其内部的 this 指向 o。

复杂的情况是通过间接方式调用函数：

```javascript
function getThis() {
  return this;
}

console.log(getThis.prototype.constructor === getThis); // true
console.log(getThis.prototype.constructor() === getThis.prototype); // true

let constructor = getThis.prototype.constructor;
console.log(constructor() === window); // true
```

在这个例子中，getThis.prototype.constructor 返回 getThis 函数对象本身。在执行 getThis.prototype.constructor()时，getThis 的直接调用者为 getThis.prototype，因此 this 指向 getThis.prototype。之后，将 getThis.prototype.constructor 赋给 constructor，并直接调用，因此 this 指向全局对象。

- 标准函数作为构造函数调用，this 指向正在构建的对象：

```javascript
function Person() {
  this.name = 'Nicholas';
  console.log(this instanceof Person); // true
}
new Person();
```

在这个例子中，Person 作为构造方法调用，this 指向被构建的对象，因此 `this instanceOf Person` 为 true。

3. **箭头函数**

箭头函数的 this 行为和标准函数的截然不同。

- 箭头函数在全局上下文中，则其 this 绑定全局对象，且严格模式和方法调用对该 this 没有影响。

来看下面几个例子：

```javascript
const getThisInArrowFunc = () => {
  'use strict';
  return this;
};

console.log(getThisInArrowFunc() === window); // true
```

在这个例子中，getThisInArrowFunc 位于全局上下文，其内部使用了严格模式，但这不影响 this 的值。this 依旧绑定全局对象。

```javascript
var name = 'window';
const o1 = {
  name: 'o1',
  o2: {
    name: 'o2',
    getThis: () => this,
  },
};
console.log(o1.o2.getThis().name); // window
```

在这个例子中，getThis 作为 o2 的方法被 o1 间接在全局上下文中调用，但不论是否作为方法被调用，getThis 都在全局上下文中，因此其内部的 this 还是绑定全局对象。

- 箭头函数在函数上下文中，则其 this 绑定紧邻的外层函数的 this。

```javascript
var name = 'window';
function foo() {
  const o1 = {
    name: 'o1',
    o2: {
      name: 'o2',
      getThis: () => this,
    },
  };
  console.log(o1.o2.getThis().name); // window
}
foo();
```

在这个例子中，箭头函数 getThis 在 foo 函数的上下文中。这里 foo 在非严格模式下直接调用，所以函数 foo 的 this 指向全局对象，箭头函数绑定了该值。

当然，如过外层的函数 foo 以方法调用，则该箭头函数内部的 this 就绑定 foo 的直接调用者。

有读者知道，在事件回调或定时回调中调用某个函数时，this 值指向的并非想要的对象。此时将回调函数写成箭头函数就可以解决问题：

```javascript
function King() {
  this.royaltyName = 'Henry';
  // this 引用King 的实例
  setTimeout(() => console.log(this.royaltyName), 1000);
}
function Queen() {
  this.royaltyName = 'Elizabeth';
  // this 引用window 对象
  setTimeout(function () {
    console.log(this.royaltyName);
  }, 1000);
}
new King(); // Henry
new Queen(); // undefined
```

### 9.4.3. new.target

ECMAScript 中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。ECMAScript 6 新增了检测函数是否使用 new 关键字调用的 new.target 属性。如果函数是正常调用的，则 new.target 的值是 undefined；如果是使用 new 关键字调用的，则 new.target 将引用被调用的构造函数。

来看这个例子：

```javascript
function foo() {
  const funcName = arguments.callee.name;
  if (new.target) {
    throw `函数${funcName}不能用作构造函数！`;
  } else {
    console.log(`函数${funcName}用为非构造函数！`);
  }
}

new foo();
foo();
```

在这个例子中，函数 foo 的名字使用 `arguments.callee.name` 取得，如果 foo 用作构造函数，则 new.target 指向构造函数本身，为非空对象，则抛出错误。如果 foo 没有用作构造函数，则 new.target 为 undefined，正常执行。

## 9.5. 函数属性

### 9.5.1. name

ECMAScript 6 的所有函数对象都会暴露一个只读的 name 属性，其中包含关于函数的信息。多数情况下，这个属性中保存的就是一个函数标识符，或者说是一个字符串化的变量名。即使函数没有名称，也会如实显示成空字符串。如果它是使用 Function 构造函数创建的，则会标识成'anonymous'：

```javascript
function foo() {}
let bar = function () {};
let baz = () => {};
console.log(foo.name); // foo
console.log(bar.name); // bar
console.log(baz.name); // baz
console.log((() => {}).name); //（空字符串）
console.log(new Function().name); // anonymous
```

如果函数是一个获取函数、设置函数，或者使用了 bind()，那么标识符前面会加上一个前缀：

```javascript
function foo() {}
console.log(foo.bind(null).name); // bound foo
let dog = {
  years: 1,
  get age() {
    return this.years;
  },
  set age(newAge) {
    this.years = newAge;
  },
};
let propertyDescriptor = Object.getOwnPropertyDescriptor(dog, 'age');
console.log(propertyDescriptor.get.name); // get age
console.log(propertyDescriptor.set.name); // set age
```

如果使用符号作为方法名称，则使用空参数符号的方法名称返回空字符串，有描述符的符号作为方法名称返回 `[描述符]`，使用内置常用符号作为方法名称返回 `[内置常用符号]`，如 `[Symbol.iterator]`。

```javascript
const emptySymbol = Symbol();
const fooSymbol = Symbol('foo');

const o = {
  [emptySymbol]() {},
  [fooSymbol]() {},
  [Symbol.iterator]() {},
};

console.log(o[emptySymbol].name); // (空字符串)
console.log(o[fooSymbol].name); // [foo]
console.log(o[Symbol.iterator].name); // [Symbol.iterator]
```

### 9.5.2. length

length 属性表示函数的命名参数的个数，它区别于 arguments.length ：这个值一般情况下是函数实际传入的参数个数。

length 的特性为 writable: false, enumerable: false, configurable: true。因此只读，不可枚举，但可配置。

来看下面这个例子：

```javascript
console.log(Function.length); // 1
console.log(function () {}.length); // 0
console.log(function (a) {}.length); // 1
console.log(function (a, b) {}.length); // 2
```

函数的构造函数 Function 本身也是一个函数，它的 length 返回 1。如果没有一个函数没有命名参数则返回 0。

需要注意的是：

- 收集参数不计入数量。
- 命名参数的计数在第一个有默认参数值的命名参数前停止。

如下所示：

```javascript
console.log(function (a, b, ...args) {}.length); // 2
console.log(function (a, b = 1, c) {}.length); // 1
```

### 9.5.3. caller

ECMAScript 5 也会给函数对象上添加一个属性：caller。虽然 ECMAScript 3 中并没有定义，但所有浏览器除了早期版本的 Opera 都支持这个属性。这个属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为 null。比如：

```javascript
function outer() {
  inner();
}
function inner() {
  console.log(inner.caller);
}
outer();
```

以上代码会显示 outer()函数的源代码。这是因为 ourter()调用了 inner()，inner.caller 指向 outer()。如果要降低耦合度，则可以通过 arguments.callee.caller 来引用同样的值：

```javascript
function outer() {
  inner();
}
function inner() {
  console.log(arguments.callee.caller);
}
outer();
```

在严格模式下访问 arguments.callee 会报错。ECMAScript 5 也定义了 arguments.caller，但在严格模式下访问它会报错，在非严格模式下则始终是 undefined。这是为了分清 arguments.caller 和函数的 caller 而故意为之的。而作为对这门语言的安全防护，这些改动也让第三方代码无法检测同一上下文中运行的其他代码。

严格模式下还有一个限制，就是不能给函数的 caller 属性赋值，否则会导致错误。

### 9.5.4. 其他属性

prototype 属性也许是 ECMAScript 核心中最有趣的部分。prototype 是保存引用类型所有实例方法的地方，这意味着 toString()、valueOf()等方法实际上都保存在 prototype 上，进而由所有实例共享。这个属性在自定义类型时特别重要。（相关内容已经在第 8 章详细介绍过了。）这个属性的特性在 ES6 中为 writable: true, enumerable: false, configurable: false。因此可写入，不可枚举，不可配置。

## 9.6. 函数方法

每个函数实例都继承了 Function 原型上的 call()，apply()，以及 bind() 方法。这些方法用于指定调用该函数时的内部 this 值。

在 10.9.2 节我们详细介绍了 this 的行为，现在让我们来回顾一下。

在标准函数上下文中，有以下规则：

- 非严格模式下直接调用函数，则其内部的 this 指向全局对象。
- 严格模式下直接调用函数，则其内部的 this 为 undefined。
- 函数作为方法调用，其内部的 this 指向直接调用者，而非间接调用者。
- 函数作为构造函数调用，其内部的 this 指向被构建的对象。

在箭头函数中，有以下规则：

- 箭头函数在全局上下文中，则其 this 绑定全局对象。
- 箭头函数在函数上下文中，则其 this 绑定紧邻的外层函数的 this 值。

### 9.6.1. call()

call(thisArg, arg1, arg2, ...) 的第一个参数 thisArg 是可选的，它指定在 function 函数运行时使用的 this 值。后面的 arg1, arg2, ... 是指定的参数。call() 方法在标准函数上使用时，有以下规则：

1. 不指定 thisArg，相当于不调用 call()。

```javascript
function showThis() {
  'use strict';
  console.log(this);
}
showThis.call(); // undefined 相当于 showThis()
```

2. 非严格模式下，thisArg 为 undefined 或 null，相当于指定了 thisArg 为全局对象。如果 thisArg 指定了其他的原始值，则相当于指定了 thisArg 为对应的包装类型。

```javascript
var name = 'window';
function showThis() {
  console.log(this.name);
}
showThis.call(undefined); // window
showThis.call(null); // window
showThis.call(0); // Number{0}
showThis.call(false); // Boolean{false}
```

3. 严格模式下，thisArg 就是所指定的值。

```javascript
function showThis() {
  'use strict';
  console.log(this);
}
showThis.call(null); // null
```

### 9.6.2. apply()

apply(thisArg, [args]) 方法和 call()方法除了 thisArg 后跟的参数不同，其他都相同。apply() 方法要求传入的参数为数组对象或类数组对象。

```javascript
function sum() {
  const result = [...arguments].reduce((pre, cur) => pre + cur, 0);
  console.log(result);
}

const arrLikeO = {
  0: 1,
  1: 2,
  2: 3,
  length: 3,
};

const arr = [1, 2, 3];

sum.apply(null, arrLikeO); // 6
sum.apply(null, arr); // 6
```

### 9.6.3. bind()

bind(thisArg, arg1, arg2, ...) 方法用于返回一个固定 this 的函数。它接收的参数中，thisArg 的含义及处理和 call() 的一致，其余参数被称为预置参数。

来看这个例子：

```javascript
const o = {name: 'o'};

function showThis() {
  console.log(this.name);
}

showThis = showThis.bind(o);

showThis(); // o
```

在这个例子中，showThis 被重写为 this 固定于 o 上的函数。在被直接调用时，如果没有 bind()，则它内部的 this 就是全局对象，会输出 undefined，但这里输出了 o。显然 this 的固定起了效果。

1. bind() 的 this 固定效果是一次性的，意思就是已经 bind 过的函数不能再 bind 一次，而且对已经 bind 过的函数调用 call() 或 apply() 方法没有影响。

来看这个例子：

```javascript
var name = 'window';
const o = {name: 'o'};

function showThis() {
  console.log(this.name);
}

showThis = showThis.bind(o);

showThis = showThis.bind(this);

showThis(); // o
showThis.call(this); // o
showThis.apply(this); // o
```

在这个例子中，虽然 showThis 在固定 this 为 o 后，再次被固定为全局对象，但 bind 的效果是一次性的，因此输出不是
window，而是 o。

2. 预置参数会自动插入传入的参数前面。

来看下面的例子：

```javascript
function sum() {
  console.log(...arguments);
  return [...arguments].reduce((pre, cur) => pre + cur, 0);
}

sum = sum.bind(null, 1, 2, 3);

console.log(sum());
// 1 2 3
// 6

console.log(sum(4));
// 1 2 3 4
// 10
```

在这个例子中，sum 函数返回参数相加的结果。之后 sum 被重写为具有预置 1，2，3 参数的函数。这就表示在调用时，这些预置参数会自动插入传入的参数前面。因此，sum() 返回 6，而 sum(4)返回 10。

需要注意的是，如果你使用预置参数就要意识到你传入的参数并不是实际的参数。

```javascript
function introduce(name, age, job) {
  console.log(`My name is ${name}, I am ${age}, and I work as a ${job}.`);
}

introduce = introduce.bind(null, 'Trigold', '20', 'Web Engineer');

introduce();
// My name is Trigold, I am 20, and I work as a Web Engineer.
introduce('Greg', '30', 'doctor');
// My name is Trigold, I am 20, and I work as a Web Engineer.
```

**箭头函数**

对于箭头函数调用以上 3 种方法，实际上箭头函数会忽略传进去的 this 参数，这就是为什么我们在箭头函数的 this 规则中说箭头函数的 this “绑定” 了什么。

来看下面的例子：

```javascript
var name = 'window';
let showThis = () => console.log(this.name);
const o = {name: 'o'};
showThis.call(o); // window
showThis.apply(o); // window
showThis = showThis.bind(o);
showThis(); // window
```

### 9.6.4. 其他函数方法

对函数而言，继承的方法 toLocaleString()和 toString()始终返回函数的代码。返回代码的具体格式因浏览器而异。有的返回源代码，包含注释，而有的只返回代码的内部形式，会删除注释，甚至代码可能被解释器修改过。由于这些差异，因此不能在重要功能中依赖这些方法返回的值，而只应在调试中使用它们。继承的方法 valueOf()返回函数本身。

## 9.7. 闭包

匿名函数经常被人误认为是 **闭包(closure)**。闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。比如，下面是之前展示的 createComparisonFunction()函数：

```javascript
function createComparisonFunction(propertyName) {
  return function (object1, object2) {
    let value1 = object1[propertyName];
    let value2 = object2[propertyName];
    if (value1 < value2) {
      return -1;
    } else if (value1 > value2) {
      return 1;
    } else {
      return 0;
    }
  };
}
```

value1 和 value2 所在的代码行位于内部函数（匿名函数）中，其中引用了外部函数的变量 propertyName。在这个内部函数被返回并在其他地方被使用后，它仍然引用着那个变量。这是因为内部函数的作用域链包含 createComparisonFunction()函数的作用域。要理解为什么会这样，可以想想第一次调用这个函数时会发生什么。

本书在第 4 章曾介绍过作用域链的概念。理解作用域链创建和使用的细节对理解闭包非常重要。在调用一个函数时，会为这个函数调用创建一个执行上下文，并创建一个作用域链。然后用 arguments 和其他命名参数来初始化这个函数的活动对象。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域链一直向外串起了所有包含函数的活动对象，直到全局执行上下文才终止。

在函数执行时，要从作用域链中查找变量，以便读、写值。来看下面的代码：

```javascript
function compare(value1, value2) {
  if (value1 < value2) {
    return -1;
  } else if (value1 > value2) {
    return 1;
  } else {
    return 0;
  }
}
let result = compare(5, 10);
```

这里定义的 compare()函数是在全局上下文中调用的。第一次调用 compare()时，会为它创建一个包含 arguments、value1 和 value2 的活动对象，这个对象是其作用域链上的第一个对象。而全局上下文的变量对象则是 compare()作用域链上的第二个对象，其中包含 this、result 和 compare。下图展示了以上关系：

![9-1-作用域链1](illustrations/9-1-作用域链1.png)

函数执行时，每个执行上下文中都会有一个包含其中变量的对象。全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，只在函数执行期间存在。在定义 compare()函数时，就会为它创建作用域链，预装载全局变量对象，并保存在内部的`[[Scope]]`中。在调用这个函数时，会创建相应的执行上下文，然后通过复制函数的`[[Scope]]`来创建其作用域链。接着会创建函数的活动对象（用作变量对象）并将其推入作用域链的前端。在这个例子中，这意味着 compare()函数执行上下文的作用域链中有两个变量对象：局部变量对象和全局变量对象。作用域链其实是一个包含指针的列表，每个指针分别指向一个变量对象，但物理上并不会包含相应的对象。

函数内部的代码在访问变量时，就会使用给定的名称从作用域链中查找变量。函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域。不过，闭包就不一样了。

在一个函数内部定义的函数会把其包含函数的活动对象添加到自己的作用域链中。因此，在 createComparisonFunction()函数中，匿名函数的作用域链中实际上包含 createComparisonFunction()的活动对象。下图展示了以下代码执行后的结果。

```javascript
let compare = createComparisonFunction('name');
let result = compare({name: 'Nicholas'}, {name: 'Matt'});
```

![9-2-作用域链2](illustrations/9-2-作用域链2.png)

在 createComparisonFunction()返回匿名函数后，它的作用域链被初始化为包含 createComparisonFunction()的活动对象和全局变量对象。这样，匿名函数就可以访问到 createComparisonFunction()可以访问的所有变量。另一个有意思的副作用就是，createComparisonFunction()的
活动对象并不能在它执行完毕后销毁，因为匿名函数的作用域链中仍然有对它的引用。在 createComparisonFunction()执行完毕后，其执行上下文的作用域链会销毁，但它的活动对象仍然会保留在内存中，直到匿名函数被销毁后才会被销毁：

```javascript
// 创建比较函数
let compareNames = createComparisonFunction('name');
// 调用函数
let result = compareNames({name: 'Nicholas'}, {name: 'Matt'});
// 解除对函数的引用，这样就可以释放内存了
compareNames = null;
```

这里，创建的比较函数被保存在变量 compareNames 中。把 compareNames 设置为等于 null 会解除对函数的引用，从而让垃圾回收程序可以将内存释放掉。作用域链也会被销毁，其他作用域（除全局作用域之外）也可以销毁。

### 9.7.1. this 对象

在闭包中使用 this 会让代码变复杂。如果内部函数没有使用箭头函数定义，则 this 对象会在运行时绑定到执行函数的上下文。如果在全局函数中调用，则 this 在非严格模式下等于 window，在严格模式下等于 undefined。如果作为某个对象的方法调用，则 this 等于这个对象。匿名函数在这种情况下不会绑定到某个对象，这就意味着 this 会指向 window，除非在严格模式下 this 是 undefined。不过，由于闭包的写法所致，这个事实有时候没有那么容易看出来。来看下面的例子：

```javascript
window.identity = 'The Window';
let object = {
  identity: 'My Object',
  getIdentityFunc() {
    return function () {
      return this.identity;
    };
  },
};
console.log(object.getIdentityFunc()()); // 'The Window'
```

这里先创建了一个全局变量 identity，之后又创建一个包含 identity 属性的对象。这个对象还包含一个 getIdentityFunc()方法，返回一个匿名函数。这个匿名函数返回 this.identity。因为 getIdentityFunc()返回函数，所以 object.getIdentityFunc()()会立即调用这个返回的函数，从而得到一个字符串。可是，此时返回的字符串是'The Winodw'，即全局变量 identity 的值。为什么匿名函数没有使用其包含作用域（getIdentityFunc()）的 this 对象呢？

前面介绍过，每个函数在被调用时都会自动创建两个特殊变量：this 和 arguments。内部函数永远不可能直接访问外部函数的这两个变量。但是，如果把 this 保存到闭包可以访问的另一个变量中，则是行得通的。比如：

```javascript
window.identity = 'The Window';
let object = {
  identity: 'My Object',
  getIdentityFunc() {
    let that = this;
    return function () {
      return that.identity;
    };
  },
};
console.log(object.getIdentityFunc()()); // 'My Object'
```

这里加粗的代码展示了与前面那个例子的区别。在定义匿名函数之前，先把外部函数的 this 保存到变量 that 中。然后在定义闭包时，就可以让它访问 that，因为这是包含函数中名称没有任何冲突的一个变量。即使在外部函数返回之后，that 仍然指向 object，所以调用 object.getIdentityFunc()()就会返回'My Object'。

注意 this 和 arguments 都是不能直接在内部函数中访问的。如果想访问包含作用域中的 arguments 对象，则同样需要将其引用先保存到闭包能访问的另一个变量中。

在一些特殊情况下，this 值可能并不是我们所期待的值。比如下面这个修改后的例子：

```javascript
window.identity = 'The Window';
let object = {
  identity: 'My Object',
  getIdentity() {
    return this.identity;
  },
};
```

getIdentity()方法就是返回 this.identity 的值。以下是几种调用 object.getIdentity()的方式及返回值：

```javascript
object.getIdentity(); // 'My Object'
object.getIdentity(); // 'My Object'
(object.getIdentity = object.getIdentity)(); // 'The Window'
```

第一行调用 object.getIdentity()是正常调用，会返回'My Object'，因为 this.identity 就是 object.identity。第二行在调用时把 object.getIdentity 放在了括号里。虽然加了括号之后看起来是对一个函数的引用，但 this 值并没有变。这是因为按照规范，object.getIdentity 和(object.getIdentity)是相等的。第三行执行了一次赋值，然后再调用赋值后的结果。因为赋值表达式的值是函数本身，this 值不再与任何对象绑定，所以返回的是'The Window'。

一般情况下，不大可能像第二行和第三行这样调用对象上的方法。但通过这个例子，我们可以知道，即使语法稍有不同，也可能影响 this 的值。

### 9.7.2. 内存泄漏

由于 IE 在 IE9 之前对 JScript 对象和 COM 对象使用了不同的垃圾回收机制（第 4 章讨论过），所以闭包在这些旧版本 IE 中可能会导致问题。在这些版本的 IE 中，把 HTML 元素保存在某个闭包的作用域中，就相当于宣布该元素不能被销毁。来看下面的例子：

```javascript
function assignHandler() {
  let element = document.getElementById('someElement');
  element.onclick = () => console.log(element.id);
}
```

以上代码创建了一个闭包，即 element 元素的事件处理程序（事件处理程序将在第 13 章讨论）。而这个处理程序又创建了一个循环引用。匿名函数引用着 assignHandler()的活动对象，阻止了对 element 的引用计数归零。只要这个匿名函数存在，element 的引用计数就至少等于 1。也就是说，内存不会被回收。其实只要这个例子稍加修改，就可以避免这种情况，比如：

```javascript
function assignHandler() {
  let element = document.getElementById('someElement');
  let id = element.id;
  element.onclick = () => console.log(id);
  element = null;
}
```

在这个修改后的版本中，闭包改为引用一个保存着 element.id 的变量 id，从而消除了循环引用。不过，光有这一步还不足以解决内存问题。因为闭包还是会引用包含函数的活动对象，而其中包含 element。即使闭包没有直接引用 element，包含函数的活动对象上还是保存着对它的引用。因此，必须再把 element 设置为 null。这样就解除了对这个 COM 对象的引用，其引用计数也会减少，从而确保其内存可以在适当的时候被回收。

## 9.9. 私有变量

严格来讲，JavaScript 没有私有成员的概念，所有对象属性都公有的。不过，倒是有 **私有变量** 的概念。任何定义在函数或块中的变量，都可以认为是私有的，因为在这个函数或块的外部无法访问其中的变量。私有变量包括函数参数、局部变量，以及函数内部定义的其他函数。来看下面的例子：

```javascript
function add(num1, num2) {
  let sum = num1 + num2;
  return sum;
}
```

在这个函数中，函数 add()有 3 个私有变量：num1、num2 和 sum。这几个变量只能在函数内部使用，不能在函数外部访问。如果这个函数中创建了一个闭包，则这个闭包能通过其作用域链访问其外部的这 3 个变量。基于这一点，就可以创建出能够访问私有变量的公有方法。

**特权方法(privileged method)** 是能够访问函数私有变量（及私有函数）的公有方法。在对象上有两种方式创建特权方法。第一种是在构造函数中实现，比如：

```javascript
function MyObject() {
  // 私有变量和私有函数
  let privateVariable = 10;
  function privateFunction() {
    return false;
  }
  // 特权方法
  this.publicMethod = function () {
    privateVariable++;
    return privateFunction();
  };
}
```

这个模式是把所有私有变量和私有函数都定义在构造函数中。然后，再创建一个能够访问这些私有成员的特权方法。这样做之所以可行，是因为定义在构造函数中的特权方法其实是一个闭包，它具有访问构造函数中定义的所有变量和函数的能力。在这个例子中，变量 privateVariable 和函数 privateFunction()只能通过 publicMethod()方法来访问。在创建 MyObject 的实例后，没有办法直接访问 privateVariable 和 privateFunction()，唯一的办法是使用 publicMethod()。

如下面的例子所示，可以定义私有变量和特权方法，以隐藏不能被直接修改的数据：

```javascript
function Person(name) {
  this.getName = function () {
    return name;
  };
  this.setName = function (value) {
    name = value;
  };
}
let person = new Person('Nicholas');
console.log(person.getName()); // 'Nicholas'
person.setName('Greg');
console.log(person.getName()); // 'Greg'
```

这段代码中的构造函数定义了两个特权方法：getName()和 setName()。每个方法都可以构造函数外部调用，并通过它们来读写私有的 name 变量。在 Person 构造函数外部，没有别的办法访问 name。因为两个方法都定义在构造函数内部，所以它们都是能够通过作用域链访问 name 的闭包。私有变量 name 对每个 Person 实例而言都是独一无二的，因为每次调用构造函数都会重新创建一套变量和方法。不过这样也有个问题：必须通过构造函数来实现这种隔离。正如第 8 章所讨论的，构造函数模式的缺点是每个实例都会重新创建一遍新方法。使用静态私有变量实现特权方法可以避免这个问题。

### 9.9.1. 静态私有变量

特权方法也可以通过使用私有作用域定义私有变量和函数来实现。这个模式如下所示：

```javascript
(function () {
  // 私有变量和私有函数
  let privateVariable = 10;
  function privateFunction() {
    return false;
  }
  // 构造函数
  MyObject = function () {};
  // 公有和特权方法
  MyObject.prototype.publicMethod = function () {
    privateVariable++;
    return privateFunction();
  };
})();
```

在这个模式中，匿名函数表达式创建了一个包含构造函数及其方法的私有作用域。首先定义的是私有变量和私有函数，然后又定义了构造函数和公有方法。公有方法定义在构造函数的原型上，与典型的原型模式一样。注意，这个模式定义的构造函数没有使用函数声明，使用的是函数表达式。函数声明会创建内部函数，在这里并不是必需的。基于同样的原因（但操作相反），这里声明 MyObject 并没有使用任何关键字。因为不使用关键字声明的变量会创建在全局作用域中，所以 MyObject 变成了全局变量，可以在这个私有作用域外部被访问。注意在严格模式下给未声明的变量赋值会导致错误。

这个模式与前一个模式的主要区别就是，私有变量和私有函数是由实例共享的。因为特权方法定义在原型上，所以同样是由实例共享的。特权方法作为一个闭包，始终引用着包含它的作用域。来看下面的例子：

```javascript
(function () {
  let name = '';
  Person = function (value) {
    name = value;
  };
  Person.prototype.getName = function () {
    return name;
  };
  Person.prototype.setName = function (value) {
    name = value;
  };
})();
let person1 = new Person('Nicholas');
console.log(person1.getName()); // 'Nicholas'
person1.setName('Matt');
console.log(person1.getName()); // 'Matt'
let person2 = new Person('Michael');
console.log(person1.getName()); // 'Michael'
console.log(person2.getName()); // 'Michael'
```

这里的 Person 构造函数可以访问私有变量 name，跟 getName()和 setName()方法一样。使用这种模式，name 变成了静态变量，可供所有实例使用。这意味着在任何实例上调用 setName()修改这个变量都会影响其他实例。调用 setName()或创建新的 Person 实例都要把 name 变量设置为一个新值。而所有实例都会返回相同的值。

像这样创建静态私有变量可以利用原型更好地重用代码，只是每个实例没有了自己的私有变量。最终，到底是把私有变量放在实例中，还是作为静态私有变量，都需要根据自己的需求来确定。

注意 使用闭包和私有变量会导致作用域链变长，作用域链越长，则查找变量所需的时间也越多。

### 9.9.2. 模块模式

前面的模式通过自定义类型创建了私有变量和特权方法。而下面要讨论的 Douglas Crockford 所说的模块模式，则在一个单例对象上实现了相同的隔离和封装。**单例对象(singleton)** 就是只有一个实例的对象。按照惯例，JavaScript 是通过对象字面量来创建单例对象的，如下面的例子所示：

```javascript
let singleton = {
  name: value,
  method() {
    // 方法的代码
  },
};
```

模块模式是在单例对象基础上加以扩展，使其通过作用域链来关联私有变量和特权方法。模块模式的样板代码如下：

```javascript
let singleton = (function () {
  // 私有变量和私有函数
  let privateVariable = 10;
  function privateFunction() {
    return false;
  }
  // 特权/公有方法和属性
  return {
    publicProperty: true,
    publicMethod() {
      privateVariable++;
      return privateFunction();
    },
  };
})();
```

模块模式使用了匿名函数返回一个对象。在匿名函数内部，首先定义私有变量和私有函数。之后，创建一个要通过匿名函数返回的对象字面量。这个对象字面量中只包含可以公开访问的属性和方法。因为这个对象定义在匿名函数内部，所以它的所有公有方法都可以访问同一个作用域的私有变量和私有函数。本质上，对象字面量定义了单例对象的公共接口。如果单例对象需要进行某种初始化，并且需要访问私有变量时，那就可以采用这个模式：

```javascript
let application = (function () {
  // 私有变量和私有函数
  let components = new Array();
  // 初始化
  components.push(new BaseComponent());
  // 公共接口
  return {
    getComponentCount() {
      return components.length;
    },
    registerComponent(component) {
      if (typeof component == 'object') {
        components.push(component);
      }
    },
  };
})();
```

在 Web 开发中，经常需要使用单例对象管理应用程序级的信息。上面这个简单的例子创建了一个 application 对象用于管理组件。在创建这个对象之后，内部就会创建一个私有的数组 components，然后将一个 BaseComponent 组件的新实例添加到数组中。（BaseComponent 组件的代码并不重要，在这里用它只是为了说明模块模式的用法。）对象字面量中定义的 getComponentCount()和 registerComponent()方法都是可以访问 components 私有数组的特权方法。前一个方法返回注册组件的数量，后一个方法负责注册新组件。

在模块模式中，单例对象作为一个模块，经过初始化可以包含某些私有的数据，而这些数据又可以通过其暴露的公共方法来访问。以这种方式创建的每个单例对象都是 Object 的实例，因为最终单例都由一个对象字面量来表示。不过这无关紧要，因为单例对象通常是可以全局访问的，而不是作为参数传给函数的，所以可以避免使用 instanceof 操作符确定参数是不是对象类型的需求。

### 9.9.3. 模块增强模式

另一个利用模块模式的做法是在返回对象之前先对其进行增强。这适合单例对象需要是某个特定类型的实例，但又必须给它添加额外属性或方法的场景。来看下面的例子：

```javascript
let singleton = (function () {
  // 私有变量和私有函数
  let privateVariable = 10;
  function privateFunction() {
    return false;
  }
  // 创建对象
  let object = new CustomType();
  // 添加特权/公有属性和方法
  object.publicProperty = true;
  object.publicMethod = function () {
    privateVariable++;
    return privateFunction();
  };
  // 返回对象
  return object;
})();
```

如果前一节的 application 对象必须是 BaseComponent 的实例，那么就可以使用下面的代码来创建它：

```javascript
let application = (function () {
  // 私有变量和私有函数
  let components = new Array();
  // 初始化
  components.push(new BaseComponent());
  // 创建局部变量保存实例
  let app = new BaseComponent();
  // 公共接口
  app.getComponentCount = function () {
    return components.length;
  };
  app.registerComponent = function (component) {
    if (typeof component == 'object') {
      components.push(component);
    }
  };
  // 返回实例
  return app;
})();
```

在这个重写的 application 单例对象的例子中，首先定义了私有变量和私有函数，跟之前例子中一样。主要区别在于这里创建了一个名为 app 的变量，其中保存了 BaseComponent 组件的实例。这是最终要变成 application 的那个对象的局部版本。在给这个局部变量 app 添加了能够访问私有变量的公共方法之后，匿名函数返回了这个对象。然后，这个对象被赋值给 application。

## 9.8. 尾调用优化

ECMAScript 6 规范新增了一项内存管理优化机制，让 JavaScript 引擎在满足条件时可以重用栈帧。具体来说，这项优化非常适合“尾调用”，即外部函数的返回值是一个内部函数的返回值。比如：

```javascript
function outerFunction() {
  return innerFunction(); // 尾调用
}
```

在 ES6 优化之前，执行这个例子会在内存中发生如下操作。

(1) 执行到 outerFunction 函数体，第一个栈帧被推到栈上。
(2) 执行 outerFunction 函数体，到 return 语句。计算返回值必须先计算 innerFunction。
(3) 执行到 innerFunction 函数体，第二个栈帧被推到栈上。
(4) 执行 innerFunction 函数体，计算其返回值。
(5) 将返回值传回 outerFunction，然后 outerFunction 再返回值。
(6) 将栈帧弹出栈外。

在 ES6 优化之后，执行这个例子会在内存中发生如下操作。

(1) 执行到 outerFunction 函数体，第一个栈帧被推到栈上。
(2) 执行 outerFunction 函数体，到达 return 语句。为求值返回语句，必须先求值 innerFunction。
(3) 引擎发现把第一个栈帧弹出栈外也没问题，因为 innerFunction 的返回值也是 outerFunction 的返回值。
(4) 弹出 outerFunction 的栈帧。
(5) 执行到 innerFunction 函数体，栈帧被推到栈上。
(6) 执行 innerFunction 函数体，计算其返回值。
(7) 将 innerFunction 的栈帧弹出栈外。

很明显，第一种情况下每多调用一次嵌套函数，就会多增加一个栈帧。而第二种情况下无论调用多少次嵌套函数，都只有一个栈帧。这就是 ES6 尾调用优化的关键：如果函数的逻辑允许基于尾调用将其销毁，则引擎就会那么做。

注意 现在还没有办法测试尾调用优化是否起作用。不过，因为这是 ES6 规范所规定的，兼容的浏览器实现都能保证在代码满足条件的情况下应用这个优化。

### 9.8.1. 尾调用优化的条件

尾调用优化的条件就是确定外部栈帧真的没有必要存在了。涉及的条件如下：

- 代码在严格模式下执行；
- 外部函数的返回值是对尾调用函数的调用；
- 尾调用函数返回后不需要执行额外的逻辑；
- 尾调用函数不是引用外部函数作用域中自由变量的闭包。

下面展示了几个违反上述条件的函数，因此都不符号尾调用优化的要求：

```javascript
'use strict';

// 无优化：尾调用没有返回
function outerFunction() {
  innerFunction();
}

// 无优化：尾调用没有直接返回
function outerFunction() {
  let innerFunctionResult = innerFunction();
  return innerFunctionResult;
}

// 无优化：尾调用返回后必须转型为字符串
function outerFunction() {
  return innerFunction().toString();
}

// 无优化：尾调用是一个闭包
function outerFunction() {
  let foo = 'bar';
  function innerFunction() {
    return foo;
  }
  return innerFunction();
}
```

下面是几个符合尾调用优化条件的例子：

```javascript
'use strict';

// 有优化：栈帧销毁前执行参数计算
function outerFunction(a, b) {
  return innerFunction(a + b);
}

// 有优化：初始返回值不涉及栈帧
function outerFunction(a, b) {
  if (a < b) {
    return a;
  }
  return innerFunction(a + b);
}

// 有优化：两个内部函数都在尾部
function outerFunction(condition) {
  return condition ? innerFunctionA() : innerFunctionB();
}
```

差异化尾调用和递归尾调用是容易让人混淆的地方。无论是递归尾调用还是非递归尾调用，都可以应用优化。引擎并不区分尾调用中调用的是函数自身还是其他函数。不过，这个优化在递归场景下的效果是最明显的，因为递归代码最容易在栈内存中迅速产生大量栈帧。

注意 之所以要求严格模式，主要因为在非严格模式下函数调用中允许使用 f.arguments 和 f.caller，而它们都会引用外部函数的栈帧。显然，这意味着不能应用优化了。因此尾调用优化要求必须在严格模式下有效，以防止引用这些属性。

### 9.8.2. 尾调用优化的代码

可以通过把简单的递归函数转换为待优化的代码来加深对尾调用优化的理解。下面是一个通过递归计算斐波纳契数列的函数：

```javascript
function fib(n) {
  if (n < 2) {
    return n;
  }
  return fib(n - 1) + fib(n - 2);
}
console.log(fib(0)); // 0
console.log(fib(1)); // 1
console.log(fib(2)); // 1
console.log(fib(3)); // 2
console.log(fib(4)); // 3
console.log(fib(5)); // 5
console.log(fib(6)); // 8
```

显然这个函数不符合尾调用优化的条件，因为返回语句中有一个相加的操作。结果，fib(n)的栈帧数的内存复杂度是 O(2n)。因此，即使这么一个简单的调用也可以给浏览器带来麻烦：

```javascript
fib(1000);
```

当然，解决这个问题也有不同的策略，比如把递归改写成迭代循环形式。不过，也可以保持递归实现，但将其重构为满足优化条件的形式。为此可以使用两个嵌套的函数，外部函数作为基础框架，内部函数执行递归：

```javascript
'use strict';
// 基础框架
function fib(n) {
  return fibImpl(0, 1, n);
}
// 执行递归
function fibImpl(a, b, n) {
  if (n === 0) {
    return a;
  }
  return fibImpl(b, a + b, n - 1);
}
```

这样重构之后，就可以满足尾调用优化的所有条件，再调用 fib(1000)就不会对浏览器造成威胁了。
