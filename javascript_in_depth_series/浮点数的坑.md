**目录：**

- [1. IEEE 754](#1-ieee-754)
- [2. 双精度浮点数的存储](#2-双精度浮点数的存储)

## 1. IEEE 754

ECMAScript 中最有意思的数据类型或许就是 Number 了。Number 类型使用 IEEE 754 格式表示整数和浮点值（在某些语言中也叫双精度(double)值）。不同的数值类型相应地也有不同的数值字面量格式。

要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。下面是几个例子：

```js
let floatNum1 = 1.1;
let floatNum2 = 0.1;
```

因为存储浮点值使用的内存空间是存储整数值的两倍，所以 ECMAScript 总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟着 0（如 1.0），那它也会被转换为整数，如下例所示：

```js
let floatNum1 = 1; // 小数点后面没有数字，当成整数1 处理
let floatNum2 = 10.0; // 小数点后面是零，当成整数10 处理
```

对于非常大或非常小的数值，浮点值可以用科学记数法来表示。科学记数法用于表示一个应该乘以 10 的给定次幂的数值。ECMAScript 中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大写或小写的字母 e，再加上一个要乘的 10 的多少次幂。比如：

```js
let floatNum = 3.125e7; // 等于31250000
```

在这个例子中，floatNum 等于 31 250 000，只不过科学记数法显得更简洁。这种表示法实际上相当于说：“以 3.125 作为系数，乘以 10 的 7 次幂。

科学记数法也可以用于表示非常小的数值，例如 0.000 000 000 000 000 03。这个数值用科学记数法可以表示为 3e-17。默认情况下，ECMAScript 会将小数点后至少包含 6 个零的浮点值转换为科学记数法（例如，0.000 000 3 会被转换为 3e-7）。

浮点值的精确度最高可达 17 位小数，但在算术计算中远不如整数精确。例如，0.1 加 0.2 得到的不是 0.3，而是 0.300 000 000 000 000 04。这种微小的舍入问题可能导致一些意想不到的结果。比如下面的例子：

```js
console.log(0.1 + 0.2 === 0.3); // false
```

IEEE 二进制浮点数算术标准（IEEE 754）是 20 世纪 80 年代以来最广泛使用的浮点数运算标准，为许多 CPU 与浮点运算器所采用。这个标准定义了表示浮点数的格式（包括负零-0）与反常值（denormal number），一些特殊数值（（无穷（Inf）与非数值（NaN）），以及这些数值的“浮点数运算符”；它也指明了四种数值舍入规则和五种例外状况（包括例外发生的时机与处理方式）。

IEEE 754 规定了四种表示浮点数值的方式：单精确度（32 位）、双精确度（64 位）、延伸单精确度（43 比特以上，很少使用）与延伸双精确度（79 比特以上，通常以 80 位实现）。只有 32 位模式有强制要求，其他都是选择性的。大部分编程语言都提供了 IEEE 浮点数格式与算术，但有些将其列为非必需的。例如，IEEE 754 问世之前就有的 C 语言，现在包括了 IEEE 算术，但不算作强制要求（C 语言的 float 通常是指 IEEE 单精确度，而 double 是指双精确度）。

## 2. 双精度浮点数的存储

双精度浮点数使用 64 个比特存储。这 64 位比特从最高到低由 1 个符号位，11 个指数位，52 个尾数位组成。如下图所示：

![双精度浮点数的存储](illustrations/3-4-双精度浮点数的存储.png)

1. **符号位**

正浮点数使用 0 表示，负浮点数使用 1 表示。

2. **指数位**

首先将一个十进制小数转为一个二进制小数。十进制小数转换成二进制小数采用"乘 2 取整，顺序排列"法。具体做法是：用 2 乘十进制小数，可以得到积，将积的整数部分取出，再用 2 乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。

然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。

例如把（0.8125）转换为二进制小数。

![3-4-十进制小数转二进制](illustrations/3-4-十进制小数转二进制.png)

但有些十进制小数不能转为有限位数的二进制小数。所有小数部分不是 2^-n (n 为整数)的十进制小数都不能转为有限的二进制小数。如 0.1，0.2。0.5，0.25 则可以转为有限的二进制小数。

实际上，十进制小数 0.1 转为二进制小数为：

0.000110011001100110011001100110011001100110011001100(1100)+

将十进制小数转为二进制小数后，再使用科学计数法，记为以下形式：

2^-4 \* 1.10011001100110011001100110011001100110011001100(1100)+

双精度浮点数规定，-4 + 1023 = 1019 再转为 11 位二进制数 01111111011 为指数位。

3. **尾数位**

尾数位是最有意思的部分。

上面提到，十进制小数 0.1 转为科学计数法的二进制小数，为：

2^-4 \* 1.10011001100110011001100110011001100110011001100(1100)+

IEEE 754 规定，为了最大限度提高精确度，可以要求尾数规范化，把尾数处理到大于等于 1 而小于 2 的区间内，便可省去前述的“1”。将这个式子中的 1.10011001100110011001100110011001100110011001100(1100)+ 去掉 "1." 后再舍入的 52 位数字称为尾数。（尾数若是超过 52 位，会判断第 53 位，若是 1 则进 1，若是 0 则舍去。）

首先去掉 "1."，为：

10011001100110011001100110011001100110011001100(1100)+

然后找到第 52 位：

100110011001100110011001100110011001100110011001100>>1<<100(1100)+

但注意到第 52 位后面的数字为 100。于是这个数字舍入后变为：

1001100110011001100110011001100110011001100110011010

至此，我们得到了完整的 0.1 的双精度浮点数位模式为：

0-01111111011-1001100110011001100110011001100110011001100110011010

4. **0.1 + 0.2**

JavaScript 里关于数字的运算，都是先转为二进制，再转成二进制的科学计数法进行存储，再取出存储值转为二级制，最后进行运算。而在先存储再取出值的过程中，就可能丢失精度。

0.1 和 0.2 存储后转为二进制的形式为：

0.0001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010 +

0.0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 010 =

0.0100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 111

计算结果转换为十进制，正好是 0.30000000000000004。

5. **Number.EPSILON**

ES6 在 Number 对象上面，新增一个极小的常量 Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。

1 的二进制科学计算法表示为：1.00...00 _ 20，其中尾数位为 52 个 0。 比 1 大的最小浮点数为：1.00...01 _ 20，其中尾数位为 51 个 0 和 1 个 1。

因此，Number.EPSILON = (1 + 2^-52) - 1 = 2^-52

即 IEEE 754 双精度浮点数在转为十进制时，最小精度为 2^-52，即 2.220446049250313e-16。

利用 Number.EPSILON 是最小精度这个特征，可以验证两个浮点数的相等性：

```js
function equals(d1, d2) {
  return Math.abs(d1 - d2) < Number.EPSILON;
}
const result = 0.1 + 0.2;
equals(result, 0.3); // true
```
