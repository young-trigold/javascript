## 1. 作用域简介

JavaScript 中（对于任何编程语言），作用域是一个关键概念。

作用域简单来说，表示标识符能够被访问的范围。

## 2. 函数作用域

在 es6 以前，JavaScript 中标识符的访问界限是函数体，因为 var 声明的标识符是函数作用域。

函数作用域的标识符访问规则是:

- 本层函数体内能够访问本层的和外层函数体中声明的标识符。
- 本层函数体内不能访问内层函数体中声明的标识符。

```javascript
var outter = function () {
  var self = function () {
    var inner = function () {};
  };
};
```

这个例子中，本层的函数体是 self 函数体。外层函数体是 outter 函数体。内层函数体是 inner 函数体。

现在让我们声明一些变量。

```javascript
var outter = function () {
  var outterVar = 'outter';
  console.log(outterVar);

  var self = function () {
    var selfVar = 'self';
    console.log(outterVar, selfVar);

    var inner = function () {
      var innerVar = 'inner';
      console.log(outterVar, selfVar, innerVar);
    };
    inner();
  };

  self();
};

outter();
// -> 'outter'
// -> 'outter' 'self'
// -> 'outter' 'self' 'inner'
```

从这个例子可以清楚地看到函数作用域的访问规则。

值得注意的是，对于函数作用域，访问界限是函数体。而不是其他的大括号，比如: if, for, while 语句所带的花括号。

```javascript
if (true) {
  var ifVar = 'if';
}

console.log(ifVar);
// -> 'if'
```

这种规则使得 es5 总是会出现一些意外，if, for, while 内的标识符会暴露到外层。

```javascript
for (var i = 0; i < 3; i++) {}

console.log(i);
// -> 3
```

es6 带来了词法作用域，使得 JavaScript 在作用域上终于“正常化”了。

## 3. 词法作用域

词法作用域的访问规则相比函数作用域来说，界限变为了任何的大括号。

es6 中，所有使用 let 或 const 声明的标识符都具有词法作用域。

```javascript
if (true) {
  const ifVar = 'if';
}

console.log(ifVar);
// -> ReferenceError: ifVar is not defined
```

这种规则使得以前在 if, for, while 中的标识符无法暴露到外界。

## 4. 标识符查找

作用域还有一个方面，就是当各层作用域的标识符名称相同时，该使用哪个呢？直觉上，肯定是使用最近的那个。实际上，JavaScript 标识符查找也是这样实现的。

```javascript
{
  const a = 0;
  {
    const a = 1;
    {
      const a = 2;
      console.log(a);
    }
  }
}
// -> 2
```

如果本层找不到，就向外层逐层查找。

```javascript
{
  const a = 0;
  {
    const a = 1;
    {
      console.log(a);
    }
  }
}
// -> 1
```

```javascript
{
  const a = 0;
  {
    {
      console.log(a);
    }
  }
}
// -> 0
```

### 4.1. 词法环境

作用域在 es6 规范中的实现其实称为 **词法环境(lexical environment)**。作用域是一个模糊的概念，更为具体的对作用域的称呼是词法环境。

词法环境是一种规范类型，用来定义标识符与基于 ECMAScript 代码嵌套结构的变量和函数之间的联系。词法环境由一个 **环境记录(Environment Records)** 和一个可能为空的到 **外层词法环境的引用(Reference to Outter Lexical Environment)** 构成。通常，词法环境和一些具体的 ECMAScript 代码的语法结构相联系，例如：函数声明，块语句或者是 Try 语句中的 Catch 子语句。这样的代码在每次估值时，新的词法环境就会被创建。

最外层的词法环境是 **全局环境(GlobalEnvironment)**。

```javascript
{
  // block0
  const a = 0;
  {
    // block1
    const a = 1;
    {
      // block2
      const a = 2;
      console.log(a);
    }
  }
}
// -> 2
```

对于这个例子而言，我们将每层块分别命名为 block0(最外层), block1, block2。

那么对于 block0 而言，它的词法环境可以表示为:

```javascript
const block0 = {
  a: 0,
  // 其他的标识符记录
  ref: GlobalEnvironment,
};
```

类似地，block1 和 block2:

```javascript
const block1 = {
  a: 1,
  ref: block0,
};

const block2 = {
  a: 2,
  ref: block1,
};
```

看到这里，对于标识符访问规则和标识符查找规则的底层原理，相信不言自明。

词法环境能够访问本层词法环境的标识符，是因为它本身就记录了这些标识符-值的记录。而能够访问外层词法环境的标识符，则是因为它的 ref 引用了外层词法环境。而标识符查找规则也很好理解，就是一个递归算法，先从本层开始查找，然后使用 ref 不断向外层词法环境查找，直到查找到标识符（这就是为什么最近的标识符被查找到）。如果最后递归到全局环境还没有查找到，就会报引用错误。

## 5. 静态作用域

但是如果作用域单单只涉及标识符访问规则，就太简单了。

JavaScript 的作用域是静态的。这点体现在一个函数能访问的标识符是由定义它的地方决定的，而不是调用它的地方（这种情况就是动态作用域）。

```javascript
const foo = 'foo';

function logFoo() {
  console.log(foo);
}

function otherFunc() {
  const foo = 'other foo';
  logFoo();
}

otherFunc();
// -> 'foo'
```

看到这个输出，很多读者可能会疑惑，根据标识符查找规则，logFoo() 不应该查找到 otherFunc() 里面的 foo，然后输出 'other foo' 吗？

这就是静态作用域的规则。实际上，调用 logFoo() 的地方会转移到定义 logFoo() 的地方执行，这样的话，logFoo() 根据标识符查找规则，就查询到全局环境的 foo，于是输出 'foo' 了。

### 5.1. 一个极好的例子

下面准备了一些综合的例子，可以帮助读者理解静态作用域。

```javascript
// 例子 1
if (true) {
  var a = 0;
}

function foo() {
  console.log(a);
}

foo();
var a = 1;
```

这个输出是多少呢？有的人可能想应该会报错把，因为调用 foo() 的地方虽然要输出 a，但是 a 在之后声明的，所以访问不到。有经验的读者可能会说是 undefined，因为 var 存在声明提升。不过有经验的读者看完这篇文章，就会知道正确的输出应该是 0，因为静态作用域和 var 的声明提升，所以 foo() 会查找到 if 中的 a，而 a 的值为 0。

```javascript
if (true) {
  let a = 0;
}

function foo() {
  console.log(a);
}

foo();
var a = 1;
```

对于这个例子而言，显然，let 变量是词法作用域，所以 foo() 访问不了 if() 里面的 a，只能访问在全局中，声明提升之后的 a，值为 undefined，因此输出 undefined。

```javascript
if (true) {
  let a = 0;
}

function foo() {
  console.log(a);
}

foo();
let a = 1;
```

对于这个例子而言，foo() 什么都访问不到，因为 let 声明的暂时性死区，还会报错: ReferenceError: Cannot access 'a' before initialization。

```javascript
if (true) {
  var a = 0;
}

function foo() {
  console.log(a);
}

foo();
let a = 1;
```

对于这个例子而言，if 中的 a 存在声明提升，被提升到了全局，foo() 能够访问到。可是同一作用域内不能出现重复声明，全局提升的 a 和底下的 let a 重复了。于是报错: SyntaxError: Identifier 'a' has already been declared。

希望读者通过这篇文章可以重新理解作用域。
