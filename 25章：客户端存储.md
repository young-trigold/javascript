**目录：**

- [25. 客户端存储](#25-客户端存储)
  - [25.1. cookie](#251-cookie)
    - [25.1.1. 限制](#2511-限制)
    - [25.1.2. cookie 的构成](#2512-cookie-的构成)
    - [25.1.3. JavaScript 中的 cookie](#2513-javascript-中的-cookie)
    - [25.1.4. 子cookie](#2514-子cookie)
    - [25.1.5. 使用 cookie 的注意事项](#2515-使用-cookie-的注意事项)
  - [25.2. Web Stroage](#252-web-stroage)
    - [25.2.1. Stroage 类型](#2521-stroage-类型)

# 25. 客户端存储

本章内容

- cookie
- 浏览器存储 API
- IndexedDB

随着 Web 应用程序的出现，直接在客户端存储用户信息的需求也随之出现。这背后的想法是合理的：与特定用户相关的信息应该保存在用户的机器上。无论是登录信息、个人偏好，还是其他数据，Web 应用程序提供者都需要有办法把它们保存在客户端。对该问题的第一个解决方案就是 cookie，cookie 由古老的网景公司发明，由一份名为 Persistent Client State: HTTP Cookies 的规范定义。今天，cookie 只是在客户端存储数据的一个选项。

## 25.1. cookie

HTTP cookie 通常也叫作 cookie，最初用于在客户端存储会话信息。这个规范要求服务器在响应 HTTP 请求时，通过发送 Set-Cookie HTTP 头部包含会话信息。例如，下面是包含这个头部的一个 HTTP 响应：

```http
HTTP/1.1 200 OK
Content-type: text/html
Set-Cookie: name=value
Other-header: other-header-value
```

这个 HTTP 响应会设置一个名为"name"，值为"value"的 cookie。名和值在发送时都会经过 URL 编码。浏览器会存储这些会话信息，并在之后的每个请求中都会通过 HTTP 头部 cookie 再将它们发回服务器，比如：

```http
GET /index.jsl HTTP/1.1
Cookie: name=value
Other-header: other-header-value
```

这些发送回服务器的额外信息可用于唯一标识发送请求的客户端。

### 25.1.1. 限制

cookie 是与特定域绑定的。设置 cookie 后，它会与请求一起发送到创建它的域。这个限制能保证 cookie 中存储的信息只对被认可的接收者开放，不被其他域访问。

因为 cookie 存储在客户端机器上，所以为保证它不会被恶意利用，浏览器会施加限制。同时，cookie 也不会占用太多磁盘空间。

通常，只要遵守以下大致的限制，就不会在任何浏览器中碰到问题：

- 不超过 300 个 cookie；
- 每个 cookie 不超过 4096 字节；
- 每个域不超过 20 个 cookie；
- 每个域不超过 81 920 字节。

每个域能设置的 cookie 总数也是受限的，但不同浏览器的限制不同。例如：

- 最新版 IE 和 Edge 限制每个域不超过 50 个 cookie；
- 最新版 Firefox 限制每个域不超过 150 个 cookie；
- 最新版 Opera 限制每个域不超过 180 个 cookie；
- Safari 和 Chrome 对每个域的 cookie 数没有硬性限制。

如果 cookie 总数超过了单个域的上限，浏览器就会删除之前设置的 cookie。IE 和 Opera 会按照最近最少使用（LRU，Least Recently Used）原则删除之前的 cookie，以便为新设置的 cookie 腾出空间。Firefox 好像会随机删除之前的 cookie，因此为避免不确定的结果，最好不要超出限制。

浏览器也会限制 cookie 的大小。大多数浏览器对 cookie 的限制是不超过 4096 字节，上下可以有一个字节的误差。为跨浏览器兼容，最好保证 cookie 的大小不超过 4095 字节。这个大小限制适用于一个域的所有 cookie，而不是单个 cookie。

如果创建的 cookie 超过最大限制，则该 cookie 会被静默删除。注意，一个字符通常会占 1 字节。如果使用多字节字符（如 UTF-8 Unicode 字符），则每个字符最多可能占 4 字节。

### 25.1.2. cookie 的构成

cookie 在浏览器中是由以下参数构成的。

- 名称：唯一标识 cookie 的名称。cookie 名不区分大小写，因此 myCookie 和 MyCookie 是同一个名称。不过，实践中最好将 cookie 名当成区分大小写来对待，因为一些服务器软件可能这样对待它们。cookie 名必须经过 URL 编码。
- 值：存储在 cookie 里的字符串值。这个值必须经过 URL 编码。
- 域：cookie 有效的域。发送到这个域的所有请求都会包含对应的 cookie。这个值可能包含子域（如www.wrox.com），也可以不包含（如.wrox.com 表示对 wrox.com 的所有子域都有效）。如果不明确设置，则默认为设置 cookie 的域。
- 路径：请求 URL 中包含这个路径才会把 cookie 发送到服务器。例如，可以指定 cookie 只能由 http://www.wrox.com/books/ 访问，因此访问 http://www.wrox.com/ 下的页面就不会发送 cookie，即使请求的是同一个域。
- 过期时间：表示何时删除 cookie 的时间戳（即什么时间之后就不发送到服务器了）。默认情况下，浏览器会话结束后会删除所有 cookie。不过，也可以设置删除 cookie 的时间。这个值是 GMT 格式（Wdy, DD-Mon-YYYY HH:MM:SS GMT），用于指定删除 cookie 的具体时间。这样即使关闭浏览器 cookie 也会保留在用户机器上。把过期时间设置为过去的时间会立即删除 cookie。
- 安全标志：设置之后，只在使用 SSL 安全连接的情况下才会把 cookie 发送到服务器。例如，请求https://www.wrox.com 会发送 cookie，而请求 http://www.wrox.com 则不会。这些参数在 Set-Cookie 头部中使用分号加空格隔开，比如：

```http
HTTP/1.1 200 OK
Content-type: text/html
Set-Cookie: name=value; expires=Mon, 22-Jan-07 07:10:24 GMT; domain=.wrox.com
Other-header: other-header-value
```

这个头部设置一个名为"name"的 cookie，这个 cookie 在 2007 年 1 月 22 日 7:10:24 过期，对www.wrox.com 及其他 wrox.com 的子域（如 p2p.wrox.com）有效。

安全标志 secure 是 cookie 中唯一的非名/值对，只需一个 secure 就可以了。比如：

```http
HTTP/1.1 200 OK
Content-type: text/html
Set-Cookie: name=value; domain=.wrox.com; path=/; secure
Other-header: other-header-value
```

这里创建的 cookie 对所有 wrox.com 的子域及该域中的所有页面有效（通过 path=/指定）。不过，这个 cookie 只能在 SSL 连接上发送，因为设置了 secure 标志。

要知道，域、路径、过期时间和 secure 标志用于告诉浏览器什么情况下应该在请求中包含 cookie。这些参数并不会随请求发送给服务器，实际发送的只有 cookie 的名/值对。

### 25.1.3. JavaScript 中的 cookie

在 JavaScript 中处理 cookie 比较麻烦，因为接口过于简单，只有 BOM 的 document.cookie 属性。根据用法不同，该属性的表现迥异。要使用该属性获取值时，document.cookie 返回包含页面中所有有效 cookie 的字符串（根据域、路径、过期时间和安全设置），以分号分隔，如下面的例子所示：

```javascript
name1 = value1;
name2 = value2;
name3 = value3;
```

所有名和值都是 URL 编码的，因此必须使用 decodeURIComponent()解码。

在设置值时，可以通过 document.cookie 属性设置新的 cookie 字符串。这个字符串在被解析后会添加到原有 cookie 中。设置 document.cookie 不会覆盖之前存在的任何 cookie，除非设置了已有的 cookie。设置 cookie 的格式如下，与 Set-Cookie 头部的格式一样：

```javascript
name = value;
expires = expiration_time;
path = domain_path;
domain = domain_name;
secure;
```

在所有这些参数中，只有 cookie 的名称和值是必需的。下面是个简单的例子：

```javascript
document.cookie = 'name=Nicholas';
```

这行代码会创建一个名为"name"的会话 cookie，其值为"Nicholas"。这个 cookie 在每次客户端向服务器发送请求时都会被带上，在浏览器关闭时就会被删除。虽然这样直接设置也可以，因为不需要在名称或值中编码任何字符，但最好还是使用 encodeURIComponent()对名称和值进行编码，比如：

```javascript
document.cookie =
  encodeURIComponent('name') + '=' + encodeURIComponent('Nicholas');
```

要为创建的 cookie 指定额外的信息，只要像 Set-Cookie 头部一样直接在后面追加相同格式的字符串即可：

```javascript
document.cookie =
  encodeURIComponent('name') +
  '=' +
  encodeURIComponent('Nicholas') +
  '; domain=.wrox.com; path=/';
```

因为在 JavaScript 中读写 cookie 不是很直观，所以可以通过辅助函数来简化相应的操作。与 cookie 相关的基本操作有读、写和删除。这些在 CookieUtil 对象中表示如下：

```javascript
class CookieUtil {
  static get(name) {
    let cookieName = `${encodeURIComponent(name)}=`,
      cookieStart = document.cookie.indexOf(cookieName),
      cookieValue = null;
    if (cookieStart > -1) {
      let cookieEnd = document.cookie.indexOf(';', cookieStart);
      if (cookieEnd == -1) {
        cookieEnd = document.cookie.length;
      }
      cookieValue = decodeURIComponent(
        document.cookie.substring(cookieStart + cookieName.length, cookieEnd),
      );
    }
    return cookieValue;
  }

  static set(name, value, expires, path, domain, secure) {
    let cookieText = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;
    if (expires instanceof Date) {
      cookieText += `; expires=${expires.toGMTString()}`;
    }
    if (path) {
      cookieText += `; path=${path}`;
    }
    if (domain) {
      cookieText += `; domain=${domain}`;
    }
    if (secure) {
      cookieText += '; secure';
    }
    document.cookie = cookieText;
  }

  static unset(name, path, domain, secure) {
    CookieUtil.set(name, '', new Date(0), path, domain, secure);
  }
}
```

CookieUtil.get()方法用于取得给定名称的cookie 值。为此，需要在document.cookie 返回的字符串中查找是否存在名称后面加上等号。如果找到了，则使用indexOf()再查找该位置后面的分号（表示该cookie 的末尾）。如果没有找到分号，说明这个cookie 在字符串末尾，因此字符串剩余部分都是cookie 的值。取得cookie 值后使用decodeURIComponent()解码，然后返回。如果没有找到cookie，则返回null。

CookieUtil.set()方法用于设置页面上的cookie，接收多个参数：cookie 名称、cookie 值、可选的Date 对象（表示何时删除cookie）、可选的URL 路径、可选的域以及可选的布尔值（表示是否添加secure 标志）。这些参数以它们的使用频率为序，只有前两个是必需的。在方法内部，使用了encodeURIComponent()对名称和值进行编码，然后再依次检查其他参数。如果expires 参数是Date对象，则使用Date 对象的toGMTString()方法添加一个expires 选项来获得正确的日期格式。剩下的代码就是简单地追加cookie 字符串，最终设置给document.cookie。

没有直接删除已有cookie 的方法。为此，需要再次设置同名cookie（包括相同路径、域和安全选项），但要将其过期时间设置为某个过去的时间。CookieUtil.unset()方法实现了这些处理。这个方法接收4 个参数：要删除cookie 的名称、可选的路径、可选的域和可选的安全标志。

这些参数会传给CookieUtil.set()，将cookie 值设置为空字符串，将过期时间设置为1970 年1 月1 日（以0 毫秒初始化的Date 对象的值）。这样可以保证删除cookie。可以像下面这样使用这些方法：

```javascript
// 设置cookie
CookieUtil.set("name", "Nicholas");
CookieUtil.set("book", "Professional JavaScript");
// 读取cookie
alert(CookieUtil.get("name")); // "Nicholas"
alert(CookieUtil.get("book")); // "Professional JavaScript"
// 删除cookie
CookieUtil.unset("name");
CookieUtil.unset("book");
// 设置有路径、域和过期时间的cookie
CookieUtil.set("name", "Nicholas", "/books/projs/", "www.wrox.com",
new Date("January 1, 2010"));
// 删除刚刚设置的cookie
CookieUtil.unset("name", "/books/projs/", "www.wrox.com");
// 设置安全cookie
CookieUtil.set("name", "Nicholas", null, null, null, true);
```

这些方法通过处理解析和cookie 字符串构建，简化了使用cookie 存储数据的操作。

### 25.1.4. 子cookie

为绕过浏览器对每个域cookie 数的限制，有些开发者提出了子cookie 的概念。子cookie 是在单个cookie 存储的小块数据，本质上是使用cookie 的值在单个cookie 中存储多个名/值对。最常用的子cookie模式如下：

```javascript
name=name1=value1&name2=value2&name3=value3&name4=value4&name5=value5
```

子cookie 的格式类似于查询字符串。这些值可以存储为单个cookie，而不用单独存储为自己的名/值对。结果就是网站或Web 应用程序能够在单域cookie 数限制下存储更多的结构化数据。

要操作子cookie，就需要再添加一些辅助方法。解析和序列化子cookie 的方式不一样，且因为对子cookie 的使用而变得更复杂。比如，要取得某个子cookie，就需要先取得cookie，然后在解码值之前需要先像下面这样找到子cookie：

```javascript
class SubCookieUtil {
static get(name, subName) {
let subCookies = SubCookieUtil.getAll(name);
return subCookies ? subCookies[subName] : null;
}
static getAll(name) {
let cookieName = encodeURIComponent(name) + "=",
cookieStart = document.cookie.indexOf(cookieName),
cookieValue = null,
cookieEnd,
subCookies,
parts,
result = {};
if (cookieStart > -1) {
cookieEnd = document.cookie.indexOf(";", cookieStart);
if (cookieEnd == -1) {
cookieEnd = document.cookie.length;
}
cookieValue = document.cookie.substring(cookieStart +
cookieName.length, cookieEnd);
if (cookieValue.length > 0) {
subCookies = cookieValue.split("&");
for (let i = 0, len = subCookies.length; i < len; i++) {
parts = subCookies[i].split("=");
result[decodeURIComponent(parts[0])] =
decodeURIComponent(parts[1]);
}
return result;
}
}
return null;
}
// 省略其他代码
};
```

取得子cookie 有两个方法：get()和getAll()。get()用于取得一个子cookie 的值，getAll()用于取得所有子cookie，并以对象形式返回，对象的属性是子cookie 的名称，值是子cookie 的值。get()方法接收两个参数：cookie 的名称和子cookie 的名称。这个方法先调用getAll()取得所有子cookie，然后返回要取得的子cookie（如果不存在则返回null）。

SubCookieUtil.getAll()方法在解析cookie 值方面与CookieUtil.get()方法非常相似。不同的是SubCookieUtil.getAll()方法不会立即解码cookie 的值，而是先用和号（&）拆分，将所有子cookie 保存到数组。然后，再基于等号（=）拆分每个子cookie，使parts 数组的第一个元素是子cookie的名称，第二个元素是子cookie 的值。两个元素都使用decodeURIComponent()解码，并添加到result对象，最后返回result 对象。如果cookie 不存在则返回null。

可以像下面这样使用这些方法：

```javascript
// 假设document.cookie=data=name=Nicholas&book=Professional%20JavaScript
// 取得所有子cookie
let data = SubCookieUtil.getAll("data");
console.log(data.name); // "Nicholas"
console.log(data.book); // "Professional JavaScript"
// 取得个别子cookie
console.log(SubCookieUtil.get("data", "name")); // "Nicholas"
console.log(SubCookieUtil.get("data", "book")); // "Professional JavaScript"
```

要写入子cookie，可以使用另外两个方法：set()和setAll()。这两个方法的实现如下：

```javascript
class SubCookieUtil {
// 省略之前的代码
static set(name, subName, value, expires, path, domain, secure) {
let subcookies = SubCookieUtil.getAll(name) || {};
subcookies[subName] = value;
SubCookieUtil.setAll(name, subcookies, expires, path, domain, secure);
}
static setAll(name, subcookies, expires, path, domain, secure) {
let cookieText = encodeURIComponent(name) + "=",
subcookieParts = new Array(),
subName;
for (subName in subcookies){
if (subName.length > 0 && subcookies.hasOwnProperty(subName)){
subcookieParts.push(
'${encodeURIComponent(subName)}=${encodeURIComponent(subcookies[subName])}');
}
}
if (cookieParts.length > 0) {
cookieText += subcookieParts.join("&");
if (expires instanceof Date) {
cookieText += `; expires=${expires.toGMTString()}`;
}
if (path) {
cookieText += `; path=${path}`;
}
if (domain) {
cookieText += `; domain=${domain}`;
}
if (secure) {
cookieText += "; secure";
}
} else {
cookieText += `; expires=${(new Date(0)).toGMTString()}`;
}
document.cookie = cookieText;
}
// 省略其他代码
};
```

set()方法接收7 个参数：cookie 的名称、子cookie 的名称、子cookie 的值、可选的Date 对象用于设置cookie 的过期时间、可选的cookie 路径、可选的cookie 域和可选的布尔值secure 标志。所有可选的参数都作用于cookie 本身，而不是子cookie。为了在同一个cookie 中存储多个子cookie，路径、域和secure 标志也必须相同。过期时间作用于整个cookie，可以在写入个别子cookie 时另行设置。在这个方法内部，第一步是取得给定cookie 名称下包含的所有子cookie。逻辑或操作符（||）在这里用于在getAll()返回null 的情况下将subcookies 设置为新对象。然后，在subcookies 上设置完子cookie 的值，再将参数传给setAll()。

setAll()方法接收6 个参数：cookie 的名称、包含所有子cookie 的对象，然后是set()方法中使用的4 个可选参数。这个方法会在for-in 循环中迭代第二个参数的属性。为保证只存储合适的数据，这里使用了hasOwnProperty()方法确保只有实例属性才会序列化为子cookie。因为存在属性名等于空字符串的可能，所以在添加到subcookieParts 数组之前也要检查属性名的长度。subcookieParts数组包含了子cookie 的名/值对，这样我们可以方便地使用join()方法用和号将它们拼接成字符串。剩下的逻辑与CookieUtil.set()一样。

可以像下面这样使用这些方法：

```javascript
// 假设document.cookie=data=name=Nicholas&book=Professional%20JavaScript
// 设置两个子cookie
SubCookieUtil.set("data", "name", "Nicholas");
SubCookieUtil.set("data", "book", "Professional JavaScript");
// 设置所有子cookie 并传入过期时间
SubCookieUtil.setAll("data", { name: "Nicholas", book: "Professional JavaScript" },
new Date("January 1, 2010"));
// 修改"name"的值并修改整个cookie 的过期时间
SubCookieUtil.set("data", "name", "Michael", new Date("February 1, 2010"));
```

最后一组子cookie 相关的方法是要删除子cookie 的。常规cookie 可以通过直接设置过期时间为某个过去的时间删除，但删除子cookie 没有这么简单。为了删除子cookie，需要先取得所有子cookie，把要删除的那个删掉，然后再把剩下的子cookie 设置回去。下面是相关方法的实现：

```javascript
class SubCookieUtil {
// 省略之前的代码
static unset(name, subName, path, domain, secure) {
let subcookies = SubCookieUtil.getAll(name);
if (subcookies){
delete subcookies[subName]; // 删除
SubCookieUtil.setAll(name, subcookies, null, path, domain, secure);
}
}
static unsetAll(name, path, domain, secure) {
SubCookieUtil.setAll(name, null, new Date(0), path, domain, secure);
}
}
```

这里定义的这两个方法有两个不同的目的。unset()方法用于从cookie 中删除一个子cookie，其他子cookie 不受影响；而unsetAll()方法与CookieUtil.unset()一样，会删除整个cookie。与set()和setAll()一样，路径、域和secure 标志必须与创建cookie 时使用的一样。可以像下面这样使用这两个方法：

```javascript
// 只删除"name"子cookie
SubCookieUtil.unset("data", "name");
// 删除整个cookie
SubCookieUtil.unsetAll("data");
```

如果实际开发中担心碰到每个域的cookie 限制，则可以考虑使用子cookie 这个方案。此时要特别注意cookie 的大小，不要超过对单个cookie 大小的限制。

### 25.1.5. 使用 cookie 的注意事项

还有一种叫作HTTP-only 的cookie。HTTP-only 可以在浏览器设置，也可以在服务器设置，但只能在服务器上读取，这是因为JavaScript 无法取得这种cookie 的值。

因为所有cookie 都会作为请求头部由浏览器发送给服务器，所以在cookie 中保存大量信息可能会影响特定域浏览器请求的性能。保存的cookie 越大，请求完成的时间就越长。即使浏览器对cookie 大小有限制，最好还是尽可能只通过cookie 保存必要信息，以避免性能问题。

对cookie 的限制及其特性决定了cookie 并不是存储大量数据的理想方式。因此，其他客户端存储技术出现了。

注意 不要在cookie 中存储重要或敏感的信息。cookie 数据不是保存在安全的环境中，因此任何人都可能获得。应该避免把信用卡号或个人地址等信息保存在cookie 中。

## 25.2. Web Stroage

Web Storage 最早是 **网页超文本应用技术工作组(WHATWG，Web Hypertext Application Technical Working Group)** 在Web Applications 1.0 规范中提出的。这个规范中的草案最终成为了HTML5 的一部分，后来又独立成为自己的规范。Web Storage 的目的是解决通过客户端存储不需要频繁发送回服务器的数据时使用cookie 的问题。

Web Storage 规范最新的版本是第2 版，这一版规范主要有两个目标：

- 提供在cookie 之外的存储会话数据的途径；
- 提供跨会话持久化存储大量数据的机制。

Web Storage 的第2 版定义了两个对象：localStorage 和sessionStorage。localStorage 是永久存储机制，sessionStorage 是跨会话的存储机制。这两种浏览器存储API 提供了在浏览器中不受页面刷新影响而存储数据的两种方式。2009 年之后所有主要供应商发布的浏览器版本在window 对象上支持localStorage 和sessionStorage。

注意 Web Storage 第1 版曾使用过globalStorage，不过目前globalStorage 已废弃。

### 25.2.1. Stroage 类型

Storage 类型用于保存名/值对数据，直至存储空间上限（由浏览器决定）。Storage 的实例与其他对象一样，但增加了以下方法。

- clear()：删除所有值；不在Firefox 中实现。
- getItem(name)：取得给定name 的值。
- key(index)：取得给定数值位置的名称。
- removeItem(name)：删除给定name 的名/值对。

// @TODO
